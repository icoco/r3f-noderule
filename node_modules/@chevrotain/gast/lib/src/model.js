"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeProduction = exports.serializeGrammar = exports.Terminal = exports.Alternation = exports.RepetitionWithSeparator = exports.Repetition = exports.RepetitionMandatoryWithSeparator = exports.RepetitionMandatory = exports.Option = exports.Alternative = exports.Rule = exports.NonTerminal = exports.AbstractProduction = void 0;
const map_1 = __importDefault(require("lodash/map"));
const forEach_1 = __importDefault(require("lodash/forEach"));
const isString_1 = __importDefault(require("lodash/isString"));
const isRegExp_1 = __importDefault(require("lodash/isRegExp"));
const pickBy_1 = __importDefault(require("lodash/pickBy"));
const assign_1 = __importDefault(require("lodash/assign"));
// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?
function tokenLabel(tokType) {
    if (hasTokenLabel(tokType)) {
        return tokType.LABEL;
    }
    else {
        return tokType.name;
    }
}
// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?
function hasTokenLabel(obj) {
    return (0, isString_1.default)(obj.LABEL) && obj.LABEL !== "";
}
class AbstractProduction {
    constructor(_definition) {
        this._definition = _definition;
    }
    get definition() {
        return this._definition;
    }
    set definition(value) {
        this._definition = value;
    }
    accept(visitor) {
        visitor.visit(this);
        (0, forEach_1.default)(this.definition, (prod) => {
            prod.accept(visitor);
        });
    }
}
exports.AbstractProduction = AbstractProduction;
class NonTerminal extends AbstractProduction {
    constructor(options) {
        super([]);
        this.idx = 1;
        (0, assign_1.default)(this, (0, pickBy_1.default)(options, (v) => v !== undefined));
    }
    set definition(definition) {
        // immutable
    }
    get definition() {
        if (this.referencedRule !== undefined) {
            return this.referencedRule.definition;
        }
        return [];
    }
    accept(visitor) {
        visitor.visit(this);
        // don't visit children of a reference, we will get cyclic infinite loops if we do so
    }
}
exports.NonTerminal = NonTerminal;
class Rule extends AbstractProduction {
    constructor(options) {
        super(options.definition);
        this.orgText = "";
        (0, assign_1.default)(this, (0, pickBy_1.default)(options, (v) => v !== undefined));
    }
}
exports.Rule = Rule;
class Alternative extends AbstractProduction {
    constructor(options) {
        super(options.definition);
        this.ignoreAmbiguities = false;
        (0, assign_1.default)(this, (0, pickBy_1.default)(options, (v) => v !== undefined));
    }
}
exports.Alternative = Alternative;
class Option extends AbstractProduction {
    constructor(options) {
        super(options.definition);
        this.idx = 1;
        (0, assign_1.default)(this, (0, pickBy_1.default)(options, (v) => v !== undefined));
    }
}
exports.Option = Option;
class RepetitionMandatory extends AbstractProduction {
    constructor(options) {
        super(options.definition);
        this.idx = 1;
        (0, assign_1.default)(this, (0, pickBy_1.default)(options, (v) => v !== undefined));
    }
}
exports.RepetitionMandatory = RepetitionMandatory;
class RepetitionMandatoryWithSeparator extends AbstractProduction {
    constructor(options) {
        super(options.definition);
        this.idx = 1;
        (0, assign_1.default)(this, (0, pickBy_1.default)(options, (v) => v !== undefined));
    }
}
exports.RepetitionMandatoryWithSeparator = RepetitionMandatoryWithSeparator;
class Repetition extends AbstractProduction {
    constructor(options) {
        super(options.definition);
        this.idx = 1;
        (0, assign_1.default)(this, (0, pickBy_1.default)(options, (v) => v !== undefined));
    }
}
exports.Repetition = Repetition;
class RepetitionWithSeparator extends AbstractProduction {
    constructor(options) {
        super(options.definition);
        this.idx = 1;
        (0, assign_1.default)(this, (0, pickBy_1.default)(options, (v) => v !== undefined));
    }
}
exports.RepetitionWithSeparator = RepetitionWithSeparator;
class Alternation extends AbstractProduction {
    constructor(options) {
        super(options.definition);
        this.idx = 1;
        this.ignoreAmbiguities = false;
        this.hasPredicates = false;
        (0, assign_1.default)(this, (0, pickBy_1.default)(options, (v) => v !== undefined));
    }
    get definition() {
        return this._definition;
    }
    set definition(value) {
        this._definition = value;
    }
}
exports.Alternation = Alternation;
class Terminal {
    constructor(options) {
        this.idx = 1;
        (0, assign_1.default)(this, (0, pickBy_1.default)(options, (v) => v !== undefined));
    }
    accept(visitor) {
        visitor.visit(this);
    }
}
exports.Terminal = Terminal;
function serializeGrammar(topRules) {
    return (0, map_1.default)(topRules, serializeProduction);
}
exports.serializeGrammar = serializeGrammar;
function serializeProduction(node) {
    function convertDefinition(definition) {
        return (0, map_1.default)(definition, serializeProduction);
    }
    /* istanbul ignore else */
    if (node instanceof NonTerminal) {
        const serializedNonTerminal = {
            type: "NonTerminal",
            name: node.nonTerminalName,
            idx: node.idx
        };
        if ((0, isString_1.default)(node.label)) {
            serializedNonTerminal.label = node.label;
        }
        return serializedNonTerminal;
    }
    else if (node instanceof Alternative) {
        return {
            type: "Alternative",
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof Option) {
        return {
            type: "Option",
            idx: node.idx,
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof RepetitionMandatory) {
        return {
            type: "RepetitionMandatory",
            idx: node.idx,
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof RepetitionMandatoryWithSeparator) {
        return {
            type: "RepetitionMandatoryWithSeparator",
            idx: node.idx,
            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof RepetitionWithSeparator) {
        return {
            type: "RepetitionWithSeparator",
            idx: node.idx,
            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof Repetition) {
        return {
            type: "Repetition",
            idx: node.idx,
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof Alternation) {
        return {
            type: "Alternation",
            idx: node.idx,
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof Terminal) {
        const serializedTerminal = {
            type: "Terminal",
            name: node.terminalType.name,
            label: tokenLabel(node.terminalType),
            idx: node.idx
        };
        if ((0, isString_1.default)(node.label)) {
            serializedTerminal.terminalLabel = node.label;
        }
        const pattern = node.terminalType.PATTERN;
        if (node.terminalType.PATTERN) {
            serializedTerminal.pattern = (0, isRegExp_1.default)(pattern)
                ? pattern.source
                : pattern;
        }
        return serializedTerminal;
    }
    else if (node instanceof Rule) {
        return {
            type: "Rule",
            name: node.name,
            orgText: node.orgText,
            definition: convertDefinition(node.definition)
        };
    }
    else {
        throw Error("non exhaustive match");
    }
}
exports.serializeProduction = serializeProduction;
//# sourceMappingURL=model.js.map