"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildModel = void 0;
const gast_1 = require("@chevrotain/gast");
const map_1 = __importDefault(require("lodash/map"));
const flatten_1 = __importDefault(require("lodash/flatten"));
const values_1 = __importDefault(require("lodash/values"));
const some_1 = __importDefault(require("lodash/some"));
const groupBy_1 = __importDefault(require("lodash/groupBy"));
const assign_1 = __importDefault(require("lodash/assign"));
function buildModel(productions) {
    const generator = new CstNodeDefinitionGenerator();
    const allRules = (0, values_1.default)(productions);
    return (0, map_1.default)(allRules, (rule) => generator.visitRule(rule));
}
exports.buildModel = buildModel;
class CstNodeDefinitionGenerator extends gast_1.GAstVisitor {
    visitRule(node) {
        const rawElements = this.visitEach(node.definition);
        const grouped = (0, groupBy_1.default)(rawElements, (el) => el.propertyName);
        const properties = (0, map_1.default)(grouped, (group, propertyName) => {
            const allNullable = !(0, some_1.default)(group, (el) => !el.canBeNull);
            // In an alternation with a label a property name can have
            // multiple types.
            let propertyType = group[0].type;
            if (group.length > 1) {
                propertyType = (0, map_1.default)(group, (g) => g.type);
            }
            return {
                name: propertyName,
                type: propertyType,
                optional: allNullable
            };
        });
        return {
            name: node.name,
            properties: properties
        };
    }
    visitAlternative(node) {
        return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
    }
    visitOption(node) {
        return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
    }
    visitRepetition(node) {
        return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
    }
    visitRepetitionMandatory(node) {
        return this.visitEach(node.definition);
    }
    visitRepetitionMandatoryWithSeparator(node) {
        return this.visitEach(node.definition).concat({
            propertyName: node.separator.name,
            canBeNull: true,
            type: getType(node.separator)
        });
    }
    visitRepetitionWithSeparator(node) {
        return this.visitEachAndOverrideWith(node.definition, {
            canBeNull: true
        }).concat({
            propertyName: node.separator.name,
            canBeNull: true,
            type: getType(node.separator)
        });
    }
    visitAlternation(node) {
        return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
    }
    visitTerminal(node) {
        return [
            {
                propertyName: node.label || node.terminalType.name,
                canBeNull: false,
                type: getType(node)
            }
        ];
    }
    visitNonTerminal(node) {
        return [
            {
                propertyName: node.label || node.nonTerminalName,
                canBeNull: false,
                type: getType(node)
            }
        ];
    }
    visitEachAndOverrideWith(definition, override) {
        return (0, map_1.default)(this.visitEach(definition), (definition) => (0, assign_1.default)({}, definition, override));
    }
    visitEach(definition) {
        return (0, flatten_1.default)((0, map_1.default)(definition, (definition) => this.visit(definition)));
    }
}
function getType(production) {
    if (production instanceof gast_1.NonTerminal) {
        return {
            kind: "rule",
            name: production.referencedRule.name
        };
    }
    return { kind: "token" };
}
//# sourceMappingURL=model.js.map