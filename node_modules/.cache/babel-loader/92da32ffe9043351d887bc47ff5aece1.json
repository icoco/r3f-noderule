{"ast":null,"code":"import * as e from \"react\";\nexport function useSize(r) {\n  const [i, t] = e.useState(void 0);\n  return e.useEffect(() => {\n    if (r) {\n      const e = new ResizeObserver(e => {\n        if (!Array.isArray(e)) return;\n        if (!e.length) return;\n        const i = e[0];\n        let o, n;\n\n        if (\"borderBoxSize\" in i) {\n          const e = i.borderBoxSize,\n                r = Array.isArray(e) ? e[0] : e;\n          o = r.inlineSize, n = r.blockSize;\n        } else {\n          const e = r.getBoundingClientRect();\n          o = e.width, n = e.height;\n        }\n\n        t({\n          width: o,\n          height: n\n        });\n      });\n      return e.observe(r, {\n        box: \"border-box\"\n      }), () => {\n        t(void 0), e.unobserve(r);\n      };\n    }\n  }, [r]), i;\n}","map":{"version":3,"sources":["packages/react/use-size/src/useSize.tsx"],"names":["useSize","element","size","setSize","React","useState","undefined","useEffect","resizeObserver","ResizeObserver","entries","Array","isArray","length","entry","width","height","borderSizeEntry","borderSize","rect","getBoundingClientRect","observe","box","unobserve"],"mappings":";OAIA,SAASA,OAAT,CAAiBC,CAAjB,EAAiBA;AACf,QAAA,CAAOC,CAAP,EAAaC,CAAb,IAAwBC,CAAAA,CAAMC,QAAND,CAAMC,KAAwDC,CAA9DF,CAAxB;AA8CA,SA5CAA,CAAAA,CAAMG,SAANH,CAAgB,MAAA;AACd,QAAIH,CAAJ,EAAa;AACX,YAAMO,CAAAA,GAAiB,IAAIC,cAAJ,CAAoBC,CAAAA,IAAAA;AACzC,YAAA,CAAKC,KAAAA,CAAMC,OAAND,CAAcD,CAAdC,CAAL,EACE;AAKF,YAAA,CAAKD,CAAAA,CAAQG,MAAb,EACE;AAGF,cAAMC,CAAAA,GAAQJ,CAAAA,CAAQ,CAARA,CAAd;AACA,YAAIK,CAAJ,EACIC,CADJ;;AAGA,YAAI,mBAAmBF,CAAvB,EAA8B;AAC5B,gBAAMG,CAAAA,GAAkBH,CAAAA,CAAK,aAA7B;AAAA,gBAEMI,CAAAA,GAAaP,KAAAA,CAAMC,OAAND,CAAcM,CAAdN,IAAiCM,CAAAA,CAAgB,CAAhBA,CAAjCN,GAAsDM,CAFzE;AAGAF,UAAAA,CAAAA,GAAQG,CAAAA,CAAU,UAAlBH,EACAC,CAAAA,GAASE,CAAAA,CAAU,SADnBH;AACmB,SALrB,MAMO;AAGL,gBAAMI,CAAAA,GAAOlB,CAAAA,CAAQmB,qBAARnB,EAAb;AACAc,UAAAA,CAAAA,GAAQI,CAAAA,CAAKJ,KAAbA,EACAC,CAAAA,GAASG,CAAAA,CAAKH,MADdD;AAIFZ;;AAAAA,QAAAA,CAAAA,CAAQ;AAAEY,UAAAA,KAAAA,EAAAA,CAAF;AAASC,UAAAA,MAAAA,EAAAA;AAAT,SAARb,CAAAA;AAAiBa,OA7BI,CAAvB;AAkCA,aAFAR,CAAAA,CAAea,OAAfb,CAAuBP,CAAvBO,EAAgC;AAAEc,QAAAA,GAAAA,EAAK;AAAP,OAAhCd,GAEO,MAAA;AACLL,QAAAA,CAAAA,CAAAA,KAAQG,CAARH,CAAAA,EACAK,CAAAA,CAAee,SAAff,CAAyBP,CAAzBO,CADAL;AACyBF,OAF3B;AAE2BA;AAAAA,GAtC/BG,EA0CG,CAACH,CAAD,CA1CHG,GA4COF,CAAP;AAAOA","sourcesContent":["/// <reference types=\"resize-observer-browser\" />\n\nimport * as React from 'react';\n\nfunction useSize(element: HTMLElement | SVGElement | null) {\n  const [size, setSize] = React.useState<{ width: number; height: number } | undefined>(undefined);\n\n  React.useEffect(() => {\n    if (element) {\n      const resizeObserver = new ResizeObserver((entries) => {\n        if (!Array.isArray(entries)) {\n          return;\n        }\n\n        // Since we only observe the one element, we don't need to loop over the\n        // array\n        if (!entries.length) {\n          return;\n        }\n\n        const entry = entries[0];\n        let width: number;\n        let height: number;\n\n        if ('borderBoxSize' in entry) {\n          const borderSizeEntry = entry['borderBoxSize'];\n          // iron out differences between browsers\n          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;\n          width = borderSize['inlineSize'];\n          height = borderSize['blockSize'];\n        } else {\n          // for browsers that don't support `borderBoxSize`\n          // we calculate a rect ourselves to get the correct border box.\n          const rect = element.getBoundingClientRect();\n          width = rect.width;\n          height = rect.height;\n        }\n\n        setSize({ width, height });\n      });\n\n      resizeObserver.observe(element, { box: 'border-box' });\n\n      return () => {\n        setSize(undefined);\n        resizeObserver.unobserve(element);\n      };\n    }\n    return;\n  }, [element]);\n\n  return size;\n}\n\nexport { useSize };\n"]},"metadata":{},"sourceType":"module"}