{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TreeBuilder = void 0;\n\nconst cst_1 = require(\"../../cst/cst\");\n\nconst noop_1 = __importDefault(require(\"lodash/noop\"));\n\nconst has_1 = __importDefault(require(\"lodash/has\"));\n\nconst keys_1 = __importDefault(require(\"lodash/keys\"));\n\nconst isUndefined_1 = __importDefault(require(\"lodash/isUndefined\"));\n\nconst cst_visitor_1 = require(\"../../cst/cst_visitor\");\n\nconst parser_1 = require(\"../parser\");\n/**\n * This trait is responsible for the CST building logic.\n */\n\n\nclass TreeBuilder {\n  initTreeBuilder(config) {\n    this.CST_STACK = []; // outputCst is no longer exposed/defined in the pubic API\n\n    this.outputCst = config.outputCst;\n    this.nodeLocationTracking = (0, has_1.default)(config, \"nodeLocationTracking\") ? config.nodeLocationTracking // assumes end user provides the correct config value/type\n    : parser_1.DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n\n    if (!this.outputCst) {\n      this.cstInvocationStateUpdate = noop_1.default;\n      this.cstFinallyStateUpdate = noop_1.default;\n      this.cstPostTerminal = noop_1.default;\n      this.cstPostNonTerminal = noop_1.default;\n      this.cstPostRule = noop_1.default;\n    } else {\n      if (/full/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = cst_1.setNodeLocationFull;\n          this.setNodeLocationFromNode = cst_1.setNodeLocationFull;\n          this.cstPostRule = noop_1.default;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n        } else {\n          this.setNodeLocationFromToken = noop_1.default;\n          this.setNodeLocationFromNode = noop_1.default;\n          this.cstPostRule = this.cstPostRuleFull;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n        }\n      } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = cst_1.setNodeLocationOnlyOffset;\n          this.setNodeLocationFromNode = cst_1.setNodeLocationOnlyOffset;\n          this.cstPostRule = noop_1.default;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;\n        } else {\n          this.setNodeLocationFromToken = noop_1.default;\n          this.setNodeLocationFromNode = noop_1.default;\n          this.cstPostRule = this.cstPostRuleOnlyOffset;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;\n        }\n      } else if (/none/i.test(this.nodeLocationTracking)) {\n        this.setNodeLocationFromToken = noop_1.default;\n        this.setNodeLocationFromNode = noop_1.default;\n        this.cstPostRule = noop_1.default;\n        this.setInitialNodeLocation = noop_1.default;\n      } else {\n        throw Error(`Invalid <nodeLocationTracking> config option: \"${config.nodeLocationTracking}\"`);\n      }\n    }\n  }\n\n  setInitialNodeLocationOnlyOffsetRecovery(cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      endOffset: NaN\n    };\n  }\n\n  setInitialNodeLocationOnlyOffsetRegular(cstNode) {\n    cstNode.location = {\n      // without error recovery the starting Location of a new CstNode is guaranteed\n      // To be the next Token's startOffset (for valid inputs).\n      // For invalid inputs there won't be any CSTOutput so this potential\n      // inaccuracy does not matter\n      startOffset: this.LA(1).startOffset,\n      endOffset: NaN\n    };\n  }\n\n  setInitialNodeLocationFullRecovery(cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      startLine: NaN,\n      startColumn: NaN,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  }\n  /**\n     *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n        * @param cstNode\n     */\n\n\n  setInitialNodeLocationFullRegular(cstNode) {\n    const nextToken = this.LA(1);\n    cstNode.location = {\n      startOffset: nextToken.startOffset,\n      startLine: nextToken.startLine,\n      startColumn: nextToken.startColumn,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  }\n\n  cstInvocationStateUpdate(fullRuleName) {\n    const cstNode = {\n      name: fullRuleName,\n      children: Object.create(null)\n    };\n    this.setInitialNodeLocation(cstNode);\n    this.CST_STACK.push(cstNode);\n  }\n\n  cstFinallyStateUpdate() {\n    this.CST_STACK.pop();\n  }\n\n  cstPostRuleFull(ruleCstNode) {\n    // casts to `required<CstNodeLocation>` are safe because `cstPostRuleFull` should only be invoked when full location is enabled\n    const prevToken = this.LA(0);\n    const loc = ruleCstNode.location; // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n      loc.endLine = prevToken.endLine;\n      loc.endColumn = prevToken.endColumn;\n    } // \"empty\" CstNode edge case\n    else {\n        loc.startOffset = NaN;\n        loc.startLine = NaN;\n        loc.startColumn = NaN;\n      }\n  }\n\n  cstPostRuleOnlyOffset(ruleCstNode) {\n    const prevToken = this.LA(0); // `location' is not null because `cstPostRuleOnlyOffset` will only be invoked when location tracking is enabled.\n\n    const loc = ruleCstNode.location; // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n    } // \"empty\" CstNode edge case\n    else {\n        loc.startOffset = NaN;\n      }\n  }\n\n  cstPostTerminal(key, consumedToken) {\n    const rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n    (0, cst_1.addTerminalToCst)(rootCst, consumedToken, key); // This is only used when **both** error recovery and CST Output are enabled.\n\n    this.setNodeLocationFromToken(rootCst.location, consumedToken);\n  }\n\n  cstPostNonTerminal(ruleCstResult, ruleName) {\n    const preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n    (0, cst_1.addNoneTerminalToCst)(preCstNode, ruleName, ruleCstResult); // This is only used when **both** error recovery and CST Output are enabled.\n\n    this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n  }\n\n  getBaseCstVisitorConstructor() {\n    if ((0, isUndefined_1.default)(this.baseCstVisitorConstructor)) {\n      const newBaseCstVisitorConstructor = (0, cst_visitor_1.createBaseSemanticVisitorConstructor)(this.className, (0, keys_1.default)(this.gastProductionsCache));\n      this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n      return newBaseCstVisitorConstructor;\n    }\n\n    return this.baseCstVisitorConstructor;\n  }\n\n  getBaseCstVisitorConstructorWithDefaults() {\n    if ((0, isUndefined_1.default)(this.baseCstVisitorWithDefaultsConstructor)) {\n      const newConstructor = (0, cst_visitor_1.createBaseVisitorConstructorWithDefaults)(this.className, (0, keys_1.default)(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\n      this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n      return newConstructor;\n    }\n\n    return this.baseCstVisitorWithDefaultsConstructor;\n  }\n\n  getLastExplicitRuleShortName() {\n    const ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 1];\n  }\n\n  getPreviousExplicitRuleShortName() {\n    const ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 2];\n  }\n\n  getLastExplicitRuleOccurrenceIndex() {\n    const occurrenceStack = this.RULE_OCCURRENCE_STACK;\n    return occurrenceStack[occurrenceStack.length - 1];\n  }\n\n}\n\nexports.TreeBuilder = TreeBuilder;","map":{"version":3,"sources":["../../../../../src/parse/parser/traits/tree_builder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TreeBuilder = void 0;\nconst cst_1 = require(\"../../cst/cst\");\nconst noop_1 = __importDefault(require(\"lodash/noop\"));\nconst has_1 = __importDefault(require(\"lodash/has\"));\nconst keys_1 = __importDefault(require(\"lodash/keys\"));\nconst isUndefined_1 = __importDefault(require(\"lodash/isUndefined\"));\nconst cst_visitor_1 = require(\"../../cst/cst_visitor\");\nconst parser_1 = require(\"../parser\");\n/**\n * This trait is responsible for the CST building logic.\n */\nclass TreeBuilder {\n    initTreeBuilder(config) {\n        this.CST_STACK = [];\n        // outputCst is no longer exposed/defined in the pubic API\n        this.outputCst = config.outputCst;\n        this.nodeLocationTracking = (0, has_1.default)(config, \"nodeLocationTracking\")\n            ? config.nodeLocationTracking // assumes end user provides the correct config value/type\n            : parser_1.DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n        if (!this.outputCst) {\n            this.cstInvocationStateUpdate = noop_1.default;\n            this.cstFinallyStateUpdate = noop_1.default;\n            this.cstPostTerminal = noop_1.default;\n            this.cstPostNonTerminal = noop_1.default;\n            this.cstPostRule = noop_1.default;\n        }\n        else {\n            if (/full/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = cst_1.setNodeLocationFull;\n                    this.setNodeLocationFromNode = cst_1.setNodeLocationFull;\n                    this.cstPostRule = noop_1.default;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = noop_1.default;\n                    this.setNodeLocationFromNode = noop_1.default;\n                    this.cstPostRule = this.cstPostRuleFull;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n                }\n            }\n            else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = cst_1.setNodeLocationOnlyOffset;\n                    this.setNodeLocationFromNode = cst_1.setNodeLocationOnlyOffset;\n                    this.cstPostRule = noop_1.default;\n                    this.setInitialNodeLocation =\n                        this.setInitialNodeLocationOnlyOffsetRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = noop_1.default;\n                    this.setNodeLocationFromNode = noop_1.default;\n                    this.cstPostRule = this.cstPostRuleOnlyOffset;\n                    this.setInitialNodeLocation =\n                        this.setInitialNodeLocationOnlyOffsetRegular;\n                }\n            }\n            else if (/none/i.test(this.nodeLocationTracking)) {\n                this.setNodeLocationFromToken = noop_1.default;\n                this.setNodeLocationFromNode = noop_1.default;\n                this.cstPostRule = noop_1.default;\n                this.setInitialNodeLocation = noop_1.default;\n            }\n            else {\n                throw Error(`Invalid <nodeLocationTracking> config option: \"${config.nodeLocationTracking}\"`);\n            }\n        }\n    }\n    setInitialNodeLocationOnlyOffsetRecovery(cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            endOffset: NaN\n        };\n    }\n    setInitialNodeLocationOnlyOffsetRegular(cstNode) {\n        cstNode.location = {\n            // without error recovery the starting Location of a new CstNode is guaranteed\n            // To be the next Token's startOffset (for valid inputs).\n            // For invalid inputs there won't be any CSTOutput so this potential\n            // inaccuracy does not matter\n            startOffset: this.LA(1).startOffset,\n            endOffset: NaN\n        };\n    }\n    setInitialNodeLocationFullRecovery(cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            startLine: NaN,\n            startColumn: NaN,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN\n        };\n    }\n    /**\n       *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n  \n       * @param cstNode\n       */\n    setInitialNodeLocationFullRegular(cstNode) {\n        const nextToken = this.LA(1);\n        cstNode.location = {\n            startOffset: nextToken.startOffset,\n            startLine: nextToken.startLine,\n            startColumn: nextToken.startColumn,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN\n        };\n    }\n    cstInvocationStateUpdate(fullRuleName) {\n        const cstNode = {\n            name: fullRuleName,\n            children: Object.create(null)\n        };\n        this.setInitialNodeLocation(cstNode);\n        this.CST_STACK.push(cstNode);\n    }\n    cstFinallyStateUpdate() {\n        this.CST_STACK.pop();\n    }\n    cstPostRuleFull(ruleCstNode) {\n        // casts to `required<CstNodeLocation>` are safe because `cstPostRuleFull` should only be invoked when full location is enabled\n        const prevToken = this.LA(0);\n        const loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n            loc.endLine = prevToken.endLine;\n            loc.endColumn = prevToken.endColumn;\n        }\n        // \"empty\" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n            loc.startLine = NaN;\n            loc.startColumn = NaN;\n        }\n    }\n    cstPostRuleOnlyOffset(ruleCstNode) {\n        const prevToken = this.LA(0);\n        // `location' is not null because `cstPostRuleOnlyOffset` will only be invoked when location tracking is enabled.\n        const loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n        }\n        // \"empty\" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n        }\n    }\n    cstPostTerminal(key, consumedToken) {\n        const rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n        (0, cst_1.addTerminalToCst)(rootCst, consumedToken, key);\n        // This is only used when **both** error recovery and CST Output are enabled.\n        this.setNodeLocationFromToken(rootCst.location, consumedToken);\n    }\n    cstPostNonTerminal(ruleCstResult, ruleName) {\n        const preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n        (0, cst_1.addNoneTerminalToCst)(preCstNode, ruleName, ruleCstResult);\n        // This is only used when **both** error recovery and CST Output are enabled.\n        this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n    }\n    getBaseCstVisitorConstructor() {\n        if ((0, isUndefined_1.default)(this.baseCstVisitorConstructor)) {\n            const newBaseCstVisitorConstructor = (0, cst_visitor_1.createBaseSemanticVisitorConstructor)(this.className, (0, keys_1.default)(this.gastProductionsCache));\n            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n            return newBaseCstVisitorConstructor;\n        }\n        return this.baseCstVisitorConstructor;\n    }\n    getBaseCstVisitorConstructorWithDefaults() {\n        if ((0, isUndefined_1.default)(this.baseCstVisitorWithDefaultsConstructor)) {\n            const newConstructor = (0, cst_visitor_1.createBaseVisitorConstructorWithDefaults)(this.className, (0, keys_1.default)(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\n            this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n            return newConstructor;\n        }\n        return this.baseCstVisitorWithDefaultsConstructor;\n    }\n    getLastExplicitRuleShortName() {\n        const ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 1];\n    }\n    getPreviousExplicitRuleShortName() {\n        const ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 2];\n    }\n    getLastExplicitRuleOccurrenceIndex() {\n        const occurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return occurrenceStack[occurrenceStack.length - 1];\n    }\n}\nexports.TreeBuilder = TreeBuilder;\n//# sourceMappingURL=tree_builder.js.map"]},"metadata":{},"sourceType":"script"}