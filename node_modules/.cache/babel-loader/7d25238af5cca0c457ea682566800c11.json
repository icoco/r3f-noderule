{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EmbeddedActionsParser = exports.CstParser = exports.Parser = exports.EMPTY_ALT = exports.ParserDefinitionErrorType = exports.DEFAULT_RULE_CONFIG = exports.DEFAULT_PARSER_CONFIG = exports.END_OF_FILE = void 0;\n\nconst isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\n\nconst map_1 = __importDefault(require(\"lodash/map\"));\n\nconst forEach_1 = __importDefault(require(\"lodash/forEach\"));\n\nconst values_1 = __importDefault(require(\"lodash/values\"));\n\nconst has_1 = __importDefault(require(\"lodash/has\"));\n\nconst clone_1 = __importDefault(require(\"lodash/clone\"));\n\nconst utils_1 = require(\"@chevrotain/utils\");\n\nconst follow_1 = require(\"../grammar/follow\");\n\nconst tokens_public_1 = require(\"../../scan/tokens_public\");\n\nconst errors_public_1 = require(\"../errors_public\");\n\nconst gast_resolver_public_1 = require(\"../grammar/gast/gast_resolver_public\");\n\nconst recoverable_1 = require(\"./traits/recoverable\");\n\nconst looksahead_1 = require(\"./traits/looksahead\");\n\nconst tree_builder_1 = require(\"./traits/tree_builder\");\n\nconst lexer_adapter_1 = require(\"./traits/lexer_adapter\");\n\nconst recognizer_api_1 = require(\"./traits/recognizer_api\");\n\nconst recognizer_engine_1 = require(\"./traits/recognizer_engine\");\n\nconst error_handler_1 = require(\"./traits/error_handler\");\n\nconst context_assist_1 = require(\"./traits/context_assist\");\n\nconst gast_recorder_1 = require(\"./traits/gast_recorder\");\n\nconst perf_tracer_1 = require(\"./traits/perf_tracer\");\n\nconst apply_mixins_1 = require(\"./utils/apply_mixins\");\n\nexports.END_OF_FILE = (0, tokens_public_1.createTokenInstance)(tokens_public_1.EOF, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\nObject.freeze(exports.END_OF_FILE);\nexports.DEFAULT_PARSER_CONFIG = Object.freeze({\n  recoveryEnabled: false,\n  maxLookahead: 3,\n  dynamicTokensEnabled: false,\n  outputCst: true,\n  errorMessageProvider: errors_public_1.defaultParserErrorProvider,\n  nodeLocationTracking: \"none\",\n  traceInitPerf: false,\n  skipValidations: false\n});\nexports.DEFAULT_RULE_CONFIG = Object.freeze({\n  recoveryValueFunc: () => undefined,\n  resyncEnabled: true\n});\nvar ParserDefinitionErrorType;\n\n(function (ParserDefinitionErrorType) {\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_RULE_NAME\"] = 0] = \"INVALID_RULE_NAME\";\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"DUPLICATE_RULE_NAME\"] = 1] = \"DUPLICATE_RULE_NAME\";\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_RULE_OVERRIDE\"] = 2] = \"INVALID_RULE_OVERRIDE\";\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"DUPLICATE_PRODUCTIONS\"] = 3] = \"DUPLICATE_PRODUCTIONS\";\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"UNRESOLVED_SUBRULE_REF\"] = 4] = \"UNRESOLVED_SUBRULE_REF\";\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"LEFT_RECURSION\"] = 5] = \"LEFT_RECURSION\";\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"NONE_LAST_EMPTY_ALT\"] = 6] = \"NONE_LAST_EMPTY_ALT\";\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"AMBIGUOUS_ALTS\"] = 7] = \"AMBIGUOUS_ALTS\";\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"CONFLICT_TOKENS_RULES_NAMESPACE\"] = 8] = \"CONFLICT_TOKENS_RULES_NAMESPACE\";\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_TOKEN_NAME\"] = 9] = \"INVALID_TOKEN_NAME\";\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"NO_NON_EMPTY_LOOKAHEAD\"] = 10] = \"NO_NON_EMPTY_LOOKAHEAD\";\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"AMBIGUOUS_PREFIX_ALTS\"] = 11] = \"AMBIGUOUS_PREFIX_ALTS\";\n  ParserDefinitionErrorType[ParserDefinitionErrorType[\"TOO_MANY_ALTS\"] = 12] = \"TOO_MANY_ALTS\";\n})(ParserDefinitionErrorType = exports.ParserDefinitionErrorType || (exports.ParserDefinitionErrorType = {}));\n\nfunction EMPTY_ALT(value = undefined) {\n  return function () {\n    return value;\n  };\n}\n\nexports.EMPTY_ALT = EMPTY_ALT;\n\nclass Parser {\n  constructor(tokenVocabulary, config) {\n    this.definitionErrors = [];\n    this.selfAnalysisDone = false;\n    const that = this;\n    that.initErrorHandler(config);\n    that.initLexerAdapter();\n    that.initLooksAhead(config);\n    that.initRecognizerEngine(tokenVocabulary, config);\n    that.initRecoverable(config);\n    that.initTreeBuilder(config);\n    that.initContentAssist();\n    that.initGastRecorder(config);\n    that.initPerformanceTracer(config);\n\n    if ((0, has_1.default)(config, \"ignoredIssues\")) {\n      throw new Error(\"The <ignoredIssues> IParserConfig property has been deprecated.\\n\\t\" + \"Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\\t\" + \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\\t\" + \"For further details.\");\n    }\n\n    this.skipValidations = (0, has_1.default)(config, \"skipValidations\") ? config.skipValidations // casting assumes the end user passing the correct type\n    : exports.DEFAULT_PARSER_CONFIG.skipValidations;\n  }\n  /**\n   *  @deprecated use the **instance** method with the same name instead\n   */\n\n\n  static performSelfAnalysis(parserInstance) {\n    throw Error(\"The **static** `performSelfAnalysis` method has been deprecated.\" + \"\\t\\nUse the **instance** method with the same name instead.\");\n  }\n\n  performSelfAnalysis() {\n    this.TRACE_INIT(\"performSelfAnalysis\", () => {\n      let defErrorsMsgs;\n      this.selfAnalysisDone = true;\n      const className = this.className;\n      this.TRACE_INIT(\"toFastProps\", () => {\n        // Without this voodoo magic the parser would be x3-x4 slower\n        // It seems it is better to invoke `toFastProperties` **before**\n        // Any manipulations of the `this` object done during the recording phase.\n        (0, utils_1.toFastProperties)(this);\n      });\n      this.TRACE_INIT(\"Grammar Recording\", () => {\n        try {\n          this.enableRecording(); // Building the GAST\n\n          (0, forEach_1.default)(this.definedRulesNames, currRuleName => {\n            const wrappedRule = this[currRuleName];\n            const originalGrammarAction = wrappedRule[\"originalGrammarAction\"];\n            let recordedRuleGast;\n            this.TRACE_INIT(`${currRuleName} Rule`, () => {\n              recordedRuleGast = this.topLevelRuleRecord(currRuleName, originalGrammarAction);\n            });\n            this.gastProductionsCache[currRuleName] = recordedRuleGast;\n          });\n        } finally {\n          this.disableRecording();\n        }\n      });\n      let resolverErrors = [];\n      this.TRACE_INIT(\"Grammar Resolving\", () => {\n        resolverErrors = (0, gast_resolver_public_1.resolveGrammar)({\n          rules: (0, values_1.default)(this.gastProductionsCache)\n        });\n        this.definitionErrors = this.definitionErrors.concat(resolverErrors);\n      });\n      this.TRACE_INIT(\"Grammar Validations\", () => {\n        // only perform additional grammar validations IFF no resolving errors have occurred.\n        // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.\n        if ((0, isEmpty_1.default)(resolverErrors) && this.skipValidations === false) {\n          const validationErrors = (0, gast_resolver_public_1.validateGrammar)({\n            rules: (0, values_1.default)(this.gastProductionsCache),\n            maxLookahead: this.maxLookahead,\n            tokenTypes: (0, values_1.default)(this.tokensMap),\n            errMsgProvider: errors_public_1.defaultGrammarValidatorErrorProvider,\n            grammarName: className\n          });\n          this.definitionErrors = this.definitionErrors.concat(validationErrors);\n        }\n      }); // this analysis may fail if the grammar is not perfectly valid\n\n      if ((0, isEmpty_1.default)(this.definitionErrors)) {\n        // The results of these computations are not needed unless error recovery is enabled.\n        if (this.recoveryEnabled) {\n          this.TRACE_INIT(\"computeAllProdsFollows\", () => {\n            const allFollows = (0, follow_1.computeAllProdsFollows)((0, values_1.default)(this.gastProductionsCache));\n            this.resyncFollows = allFollows;\n          });\n        }\n\n        this.TRACE_INIT(\"ComputeLookaheadFunctions\", () => {\n          this.preComputeLookaheadFunctions((0, values_1.default)(this.gastProductionsCache));\n        });\n      }\n\n      if (!Parser.DEFER_DEFINITION_ERRORS_HANDLING && !(0, isEmpty_1.default)(this.definitionErrors)) {\n        defErrorsMsgs = (0, map_1.default)(this.definitionErrors, defError => defError.message);\n        throw new Error(`Parser Definition Errors detected:\\n ${defErrorsMsgs.join(\"\\n-------------------------------\\n\")}`);\n      }\n    });\n  }\n\n}\n\nexports.Parser = Parser; // Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.\n// (normally during the parser's constructor).\n// This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,\n// for example: duplicate rule names, referencing an unresolved subrule, ect...\n// This flag should not be enabled during normal usage, it is used in special situations, for example when\n// needing to display the parser definition errors in some GUI(online playground).\n\nParser.DEFER_DEFINITION_ERRORS_HANDLING = false;\n(0, apply_mixins_1.applyMixins)(Parser, [recoverable_1.Recoverable, looksahead_1.LooksAhead, tree_builder_1.TreeBuilder, lexer_adapter_1.LexerAdapter, recognizer_engine_1.RecognizerEngine, recognizer_api_1.RecognizerApi, error_handler_1.ErrorHandler, context_assist_1.ContentAssist, gast_recorder_1.GastRecorder, perf_tracer_1.PerformanceTracer]);\n\nclass CstParser extends Parser {\n  constructor(tokenVocabulary, config = exports.DEFAULT_PARSER_CONFIG) {\n    const configClone = (0, clone_1.default)(config);\n    configClone.outputCst = true;\n    super(tokenVocabulary, configClone);\n  }\n\n}\n\nexports.CstParser = CstParser;\n\nclass EmbeddedActionsParser extends Parser {\n  constructor(tokenVocabulary, config = exports.DEFAULT_PARSER_CONFIG) {\n    const configClone = (0, clone_1.default)(config);\n    configClone.outputCst = false;\n    super(tokenVocabulary, configClone);\n  }\n\n}\n\nexports.EmbeddedActionsParser = EmbeddedActionsParser;","map":{"version":3,"sources":["../../../../src/parse/parser/parser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EmbeddedActionsParser = exports.CstParser = exports.Parser = exports.EMPTY_ALT = exports.ParserDefinitionErrorType = exports.DEFAULT_RULE_CONFIG = exports.DEFAULT_PARSER_CONFIG = exports.END_OF_FILE = void 0;\nconst isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\nconst map_1 = __importDefault(require(\"lodash/map\"));\nconst forEach_1 = __importDefault(require(\"lodash/forEach\"));\nconst values_1 = __importDefault(require(\"lodash/values\"));\nconst has_1 = __importDefault(require(\"lodash/has\"));\nconst clone_1 = __importDefault(require(\"lodash/clone\"));\nconst utils_1 = require(\"@chevrotain/utils\");\nconst follow_1 = require(\"../grammar/follow\");\nconst tokens_public_1 = require(\"../../scan/tokens_public\");\nconst errors_public_1 = require(\"../errors_public\");\nconst gast_resolver_public_1 = require(\"../grammar/gast/gast_resolver_public\");\nconst recoverable_1 = require(\"./traits/recoverable\");\nconst looksahead_1 = require(\"./traits/looksahead\");\nconst tree_builder_1 = require(\"./traits/tree_builder\");\nconst lexer_adapter_1 = require(\"./traits/lexer_adapter\");\nconst recognizer_api_1 = require(\"./traits/recognizer_api\");\nconst recognizer_engine_1 = require(\"./traits/recognizer_engine\");\nconst error_handler_1 = require(\"./traits/error_handler\");\nconst context_assist_1 = require(\"./traits/context_assist\");\nconst gast_recorder_1 = require(\"./traits/gast_recorder\");\nconst perf_tracer_1 = require(\"./traits/perf_tracer\");\nconst apply_mixins_1 = require(\"./utils/apply_mixins\");\nexports.END_OF_FILE = (0, tokens_public_1.createTokenInstance)(tokens_public_1.EOF, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\nObject.freeze(exports.END_OF_FILE);\nexports.DEFAULT_PARSER_CONFIG = Object.freeze({\n    recoveryEnabled: false,\n    maxLookahead: 3,\n    dynamicTokensEnabled: false,\n    outputCst: true,\n    errorMessageProvider: errors_public_1.defaultParserErrorProvider,\n    nodeLocationTracking: \"none\",\n    traceInitPerf: false,\n    skipValidations: false\n});\nexports.DEFAULT_RULE_CONFIG = Object.freeze({\n    recoveryValueFunc: () => undefined,\n    resyncEnabled: true\n});\nvar ParserDefinitionErrorType;\n(function (ParserDefinitionErrorType) {\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_RULE_NAME\"] = 0] = \"INVALID_RULE_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"DUPLICATE_RULE_NAME\"] = 1] = \"DUPLICATE_RULE_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_RULE_OVERRIDE\"] = 2] = \"INVALID_RULE_OVERRIDE\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"DUPLICATE_PRODUCTIONS\"] = 3] = \"DUPLICATE_PRODUCTIONS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"UNRESOLVED_SUBRULE_REF\"] = 4] = \"UNRESOLVED_SUBRULE_REF\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"LEFT_RECURSION\"] = 5] = \"LEFT_RECURSION\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"NONE_LAST_EMPTY_ALT\"] = 6] = \"NONE_LAST_EMPTY_ALT\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"AMBIGUOUS_ALTS\"] = 7] = \"AMBIGUOUS_ALTS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"CONFLICT_TOKENS_RULES_NAMESPACE\"] = 8] = \"CONFLICT_TOKENS_RULES_NAMESPACE\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_TOKEN_NAME\"] = 9] = \"INVALID_TOKEN_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"NO_NON_EMPTY_LOOKAHEAD\"] = 10] = \"NO_NON_EMPTY_LOOKAHEAD\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"AMBIGUOUS_PREFIX_ALTS\"] = 11] = \"AMBIGUOUS_PREFIX_ALTS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"TOO_MANY_ALTS\"] = 12] = \"TOO_MANY_ALTS\";\n})(ParserDefinitionErrorType = exports.ParserDefinitionErrorType || (exports.ParserDefinitionErrorType = {}));\nfunction EMPTY_ALT(value = undefined) {\n    return function () {\n        return value;\n    };\n}\nexports.EMPTY_ALT = EMPTY_ALT;\nclass Parser {\n    constructor(tokenVocabulary, config) {\n        this.definitionErrors = [];\n        this.selfAnalysisDone = false;\n        const that = this;\n        that.initErrorHandler(config);\n        that.initLexerAdapter();\n        that.initLooksAhead(config);\n        that.initRecognizerEngine(tokenVocabulary, config);\n        that.initRecoverable(config);\n        that.initTreeBuilder(config);\n        that.initContentAssist();\n        that.initGastRecorder(config);\n        that.initPerformanceTracer(config);\n        if ((0, has_1.default)(config, \"ignoredIssues\")) {\n            throw new Error(\"The <ignoredIssues> IParserConfig property has been deprecated.\\n\\t\" +\n                \"Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\\t\" +\n                \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\\t\" +\n                \"For further details.\");\n        }\n        this.skipValidations = (0, has_1.default)(config, \"skipValidations\")\n            ? config.skipValidations // casting assumes the end user passing the correct type\n            : exports.DEFAULT_PARSER_CONFIG.skipValidations;\n    }\n    /**\n     *  @deprecated use the **instance** method with the same name instead\n     */\n    static performSelfAnalysis(parserInstance) {\n        throw Error(\"The **static** `performSelfAnalysis` method has been deprecated.\" +\n            \"\\t\\nUse the **instance** method with the same name instead.\");\n    }\n    performSelfAnalysis() {\n        this.TRACE_INIT(\"performSelfAnalysis\", () => {\n            let defErrorsMsgs;\n            this.selfAnalysisDone = true;\n            const className = this.className;\n            this.TRACE_INIT(\"toFastProps\", () => {\n                // Without this voodoo magic the parser would be x3-x4 slower\n                // It seems it is better to invoke `toFastProperties` **before**\n                // Any manipulations of the `this` object done during the recording phase.\n                (0, utils_1.toFastProperties)(this);\n            });\n            this.TRACE_INIT(\"Grammar Recording\", () => {\n                try {\n                    this.enableRecording();\n                    // Building the GAST\n                    (0, forEach_1.default)(this.definedRulesNames, (currRuleName) => {\n                        const wrappedRule = this[currRuleName];\n                        const originalGrammarAction = wrappedRule[\"originalGrammarAction\"];\n                        let recordedRuleGast;\n                        this.TRACE_INIT(`${currRuleName} Rule`, () => {\n                            recordedRuleGast = this.topLevelRuleRecord(currRuleName, originalGrammarAction);\n                        });\n                        this.gastProductionsCache[currRuleName] = recordedRuleGast;\n                    });\n                }\n                finally {\n                    this.disableRecording();\n                }\n            });\n            let resolverErrors = [];\n            this.TRACE_INIT(\"Grammar Resolving\", () => {\n                resolverErrors = (0, gast_resolver_public_1.resolveGrammar)({\n                    rules: (0, values_1.default)(this.gastProductionsCache)\n                });\n                this.definitionErrors = this.definitionErrors.concat(resolverErrors);\n            });\n            this.TRACE_INIT(\"Grammar Validations\", () => {\n                // only perform additional grammar validations IFF no resolving errors have occurred.\n                // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.\n                if ((0, isEmpty_1.default)(resolverErrors) && this.skipValidations === false) {\n                    const validationErrors = (0, gast_resolver_public_1.validateGrammar)({\n                        rules: (0, values_1.default)(this.gastProductionsCache),\n                        maxLookahead: this.maxLookahead,\n                        tokenTypes: (0, values_1.default)(this.tokensMap),\n                        errMsgProvider: errors_public_1.defaultGrammarValidatorErrorProvider,\n                        grammarName: className\n                    });\n                    this.definitionErrors = this.definitionErrors.concat(validationErrors);\n                }\n            });\n            // this analysis may fail if the grammar is not perfectly valid\n            if ((0, isEmpty_1.default)(this.definitionErrors)) {\n                // The results of these computations are not needed unless error recovery is enabled.\n                if (this.recoveryEnabled) {\n                    this.TRACE_INIT(\"computeAllProdsFollows\", () => {\n                        const allFollows = (0, follow_1.computeAllProdsFollows)((0, values_1.default)(this.gastProductionsCache));\n                        this.resyncFollows = allFollows;\n                    });\n                }\n                this.TRACE_INIT(\"ComputeLookaheadFunctions\", () => {\n                    this.preComputeLookaheadFunctions((0, values_1.default)(this.gastProductionsCache));\n                });\n            }\n            if (!Parser.DEFER_DEFINITION_ERRORS_HANDLING &&\n                !(0, isEmpty_1.default)(this.definitionErrors)) {\n                defErrorsMsgs = (0, map_1.default)(this.definitionErrors, (defError) => defError.message);\n                throw new Error(`Parser Definition Errors detected:\\n ${defErrorsMsgs.join(\"\\n-------------------------------\\n\")}`);\n            }\n        });\n    }\n}\nexports.Parser = Parser;\n// Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.\n// (normally during the parser's constructor).\n// This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,\n// for example: duplicate rule names, referencing an unresolved subrule, ect...\n// This flag should not be enabled during normal usage, it is used in special situations, for example when\n// needing to display the parser definition errors in some GUI(online playground).\nParser.DEFER_DEFINITION_ERRORS_HANDLING = false;\n(0, apply_mixins_1.applyMixins)(Parser, [\n    recoverable_1.Recoverable,\n    looksahead_1.LooksAhead,\n    tree_builder_1.TreeBuilder,\n    lexer_adapter_1.LexerAdapter,\n    recognizer_engine_1.RecognizerEngine,\n    recognizer_api_1.RecognizerApi,\n    error_handler_1.ErrorHandler,\n    context_assist_1.ContentAssist,\n    gast_recorder_1.GastRecorder,\n    perf_tracer_1.PerformanceTracer\n]);\nclass CstParser extends Parser {\n    constructor(tokenVocabulary, config = exports.DEFAULT_PARSER_CONFIG) {\n        const configClone = (0, clone_1.default)(config);\n        configClone.outputCst = true;\n        super(tokenVocabulary, configClone);\n    }\n}\nexports.CstParser = CstParser;\nclass EmbeddedActionsParser extends Parser {\n    constructor(tokenVocabulary, config = exports.DEFAULT_PARSER_CONFIG) {\n        const configClone = (0, clone_1.default)(config);\n        configClone.outputCst = false;\n        super(tokenVocabulary, configClone);\n    }\n}\nexports.EmbeddedActionsParser = EmbeddedActionsParser;\n//# sourceMappingURL=parser.js.map"]},"metadata":{},"sourceType":"script"}