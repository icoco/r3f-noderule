{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.serializeProduction = exports.serializeGrammar = exports.Terminal = exports.Alternation = exports.RepetitionWithSeparator = exports.Repetition = exports.RepetitionMandatoryWithSeparator = exports.RepetitionMandatory = exports.Option = exports.Alternative = exports.Rule = exports.NonTerminal = exports.AbstractProduction = void 0;\n\nconst map_1 = __importDefault(require(\"lodash/map\"));\n\nconst forEach_1 = __importDefault(require(\"lodash/forEach\"));\n\nconst isString_1 = __importDefault(require(\"lodash/isString\"));\n\nconst isRegExp_1 = __importDefault(require(\"lodash/isRegExp\"));\n\nconst pickBy_1 = __importDefault(require(\"lodash/pickBy\"));\n\nconst assign_1 = __importDefault(require(\"lodash/assign\")); // TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\n\n\nfunction tokenLabel(tokType) {\n  if (hasTokenLabel(tokType)) {\n    return tokType.LABEL;\n  } else {\n    return tokType.name;\n  }\n} // TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\n\n\nfunction hasTokenLabel(obj) {\n  return (0, isString_1.default)(obj.LABEL) && obj.LABEL !== \"\";\n}\n\nclass AbstractProduction {\n  constructor(_definition) {\n    this._definition = _definition;\n  }\n\n  get definition() {\n    return this._definition;\n  }\n\n  set definition(value) {\n    this._definition = value;\n  }\n\n  accept(visitor) {\n    visitor.visit(this);\n    (0, forEach_1.default)(this.definition, prod => {\n      prod.accept(visitor);\n    });\n  }\n\n}\n\nexports.AbstractProduction = AbstractProduction;\n\nclass NonTerminal extends AbstractProduction {\n  constructor(options) {\n    super([]);\n    this.idx = 1;\n    (0, assign_1.default)(this, (0, pickBy_1.default)(options, v => v !== undefined));\n  }\n\n  set definition(definition) {// immutable\n  }\n\n  get definition() {\n    if (this.referencedRule !== undefined) {\n      return this.referencedRule.definition;\n    }\n\n    return [];\n  }\n\n  accept(visitor) {\n    visitor.visit(this); // don't visit children of a reference, we will get cyclic infinite loops if we do so\n  }\n\n}\n\nexports.NonTerminal = NonTerminal;\n\nclass Rule extends AbstractProduction {\n  constructor(options) {\n    super(options.definition);\n    this.orgText = \"\";\n    (0, assign_1.default)(this, (0, pickBy_1.default)(options, v => v !== undefined));\n  }\n\n}\n\nexports.Rule = Rule;\n\nclass Alternative extends AbstractProduction {\n  constructor(options) {\n    super(options.definition);\n    this.ignoreAmbiguities = false;\n    (0, assign_1.default)(this, (0, pickBy_1.default)(options, v => v !== undefined));\n  }\n\n}\n\nexports.Alternative = Alternative;\n\nclass Option extends AbstractProduction {\n  constructor(options) {\n    super(options.definition);\n    this.idx = 1;\n    (0, assign_1.default)(this, (0, pickBy_1.default)(options, v => v !== undefined));\n  }\n\n}\n\nexports.Option = Option;\n\nclass RepetitionMandatory extends AbstractProduction {\n  constructor(options) {\n    super(options.definition);\n    this.idx = 1;\n    (0, assign_1.default)(this, (0, pickBy_1.default)(options, v => v !== undefined));\n  }\n\n}\n\nexports.RepetitionMandatory = RepetitionMandatory;\n\nclass RepetitionMandatoryWithSeparator extends AbstractProduction {\n  constructor(options) {\n    super(options.definition);\n    this.idx = 1;\n    (0, assign_1.default)(this, (0, pickBy_1.default)(options, v => v !== undefined));\n  }\n\n}\n\nexports.RepetitionMandatoryWithSeparator = RepetitionMandatoryWithSeparator;\n\nclass Repetition extends AbstractProduction {\n  constructor(options) {\n    super(options.definition);\n    this.idx = 1;\n    (0, assign_1.default)(this, (0, pickBy_1.default)(options, v => v !== undefined));\n  }\n\n}\n\nexports.Repetition = Repetition;\n\nclass RepetitionWithSeparator extends AbstractProduction {\n  constructor(options) {\n    super(options.definition);\n    this.idx = 1;\n    (0, assign_1.default)(this, (0, pickBy_1.default)(options, v => v !== undefined));\n  }\n\n}\n\nexports.RepetitionWithSeparator = RepetitionWithSeparator;\n\nclass Alternation extends AbstractProduction {\n  constructor(options) {\n    super(options.definition);\n    this.idx = 1;\n    this.ignoreAmbiguities = false;\n    this.hasPredicates = false;\n    (0, assign_1.default)(this, (0, pickBy_1.default)(options, v => v !== undefined));\n  }\n\n  get definition() {\n    return this._definition;\n  }\n\n  set definition(value) {\n    this._definition = value;\n  }\n\n}\n\nexports.Alternation = Alternation;\n\nclass Terminal {\n  constructor(options) {\n    this.idx = 1;\n    (0, assign_1.default)(this, (0, pickBy_1.default)(options, v => v !== undefined));\n  }\n\n  accept(visitor) {\n    visitor.visit(this);\n  }\n\n}\n\nexports.Terminal = Terminal;\n\nfunction serializeGrammar(topRules) {\n  return (0, map_1.default)(topRules, serializeProduction);\n}\n\nexports.serializeGrammar = serializeGrammar;\n\nfunction serializeProduction(node) {\n  function convertDefinition(definition) {\n    return (0, map_1.default)(definition, serializeProduction);\n  }\n  /* istanbul ignore else */\n\n\n  if (node instanceof NonTerminal) {\n    const serializedNonTerminal = {\n      type: \"NonTerminal\",\n      name: node.nonTerminalName,\n      idx: node.idx\n    };\n\n    if ((0, isString_1.default)(node.label)) {\n      serializedNonTerminal.label = node.label;\n    }\n\n    return serializedNonTerminal;\n  } else if (node instanceof Alternative) {\n    return {\n      type: \"Alternative\",\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Option) {\n    return {\n      type: \"Option\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionMandatory) {\n    return {\n      type: \"RepetitionMandatory\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionMandatoryWithSeparator) {\n    return {\n      type: \"RepetitionMandatoryWithSeparator\",\n      idx: node.idx,\n      separator: serializeProduction(new Terminal({\n        terminalType: node.separator\n      })),\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionWithSeparator) {\n    return {\n      type: \"RepetitionWithSeparator\",\n      idx: node.idx,\n      separator: serializeProduction(new Terminal({\n        terminalType: node.separator\n      })),\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Repetition) {\n    return {\n      type: \"Repetition\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Alternation) {\n    return {\n      type: \"Alternation\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Terminal) {\n    const serializedTerminal = {\n      type: \"Terminal\",\n      name: node.terminalType.name,\n      label: tokenLabel(node.terminalType),\n      idx: node.idx\n    };\n\n    if ((0, isString_1.default)(node.label)) {\n      serializedTerminal.terminalLabel = node.label;\n    }\n\n    const pattern = node.terminalType.PATTERN;\n\n    if (node.terminalType.PATTERN) {\n      serializedTerminal.pattern = (0, isRegExp_1.default)(pattern) ? pattern.source : pattern;\n    }\n\n    return serializedTerminal;\n  } else if (node instanceof Rule) {\n    return {\n      type: \"Rule\",\n      name: node.name,\n      orgText: node.orgText,\n      definition: convertDefinition(node.definition)\n    };\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nexports.serializeProduction = serializeProduction;","map":{"version":3,"sources":["../../src/model.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.serializeProduction = exports.serializeGrammar = exports.Terminal = exports.Alternation = exports.RepetitionWithSeparator = exports.Repetition = exports.RepetitionMandatoryWithSeparator = exports.RepetitionMandatory = exports.Option = exports.Alternative = exports.Rule = exports.NonTerminal = exports.AbstractProduction = void 0;\nconst map_1 = __importDefault(require(\"lodash/map\"));\nconst forEach_1 = __importDefault(require(\"lodash/forEach\"));\nconst isString_1 = __importDefault(require(\"lodash/isString\"));\nconst isRegExp_1 = __importDefault(require(\"lodash/isRegExp\"));\nconst pickBy_1 = __importDefault(require(\"lodash/pickBy\"));\nconst assign_1 = __importDefault(require(\"lodash/assign\"));\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\nfunction tokenLabel(tokType) {\n    if (hasTokenLabel(tokType)) {\n        return tokType.LABEL;\n    }\n    else {\n        return tokType.name;\n    }\n}\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\nfunction hasTokenLabel(obj) {\n    return (0, isString_1.default)(obj.LABEL) && obj.LABEL !== \"\";\n}\nclass AbstractProduction {\n    constructor(_definition) {\n        this._definition = _definition;\n    }\n    get definition() {\n        return this._definition;\n    }\n    set definition(value) {\n        this._definition = value;\n    }\n    accept(visitor) {\n        visitor.visit(this);\n        (0, forEach_1.default)(this.definition, (prod) => {\n            prod.accept(visitor);\n        });\n    }\n}\nexports.AbstractProduction = AbstractProduction;\nclass NonTerminal extends AbstractProduction {\n    constructor(options) {\n        super([]);\n        this.idx = 1;\n        (0, assign_1.default)(this, (0, pickBy_1.default)(options, (v) => v !== undefined));\n    }\n    set definition(definition) {\n        // immutable\n    }\n    get definition() {\n        if (this.referencedRule !== undefined) {\n            return this.referencedRule.definition;\n        }\n        return [];\n    }\n    accept(visitor) {\n        visitor.visit(this);\n        // don't visit children of a reference, we will get cyclic infinite loops if we do so\n    }\n}\nexports.NonTerminal = NonTerminal;\nclass Rule extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.orgText = \"\";\n        (0, assign_1.default)(this, (0, pickBy_1.default)(options, (v) => v !== undefined));\n    }\n}\nexports.Rule = Rule;\nclass Alternative extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.ignoreAmbiguities = false;\n        (0, assign_1.default)(this, (0, pickBy_1.default)(options, (v) => v !== undefined));\n    }\n}\nexports.Alternative = Alternative;\nclass Option extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        (0, assign_1.default)(this, (0, pickBy_1.default)(options, (v) => v !== undefined));\n    }\n}\nexports.Option = Option;\nclass RepetitionMandatory extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        (0, assign_1.default)(this, (0, pickBy_1.default)(options, (v) => v !== undefined));\n    }\n}\nexports.RepetitionMandatory = RepetitionMandatory;\nclass RepetitionMandatoryWithSeparator extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        (0, assign_1.default)(this, (0, pickBy_1.default)(options, (v) => v !== undefined));\n    }\n}\nexports.RepetitionMandatoryWithSeparator = RepetitionMandatoryWithSeparator;\nclass Repetition extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        (0, assign_1.default)(this, (0, pickBy_1.default)(options, (v) => v !== undefined));\n    }\n}\nexports.Repetition = Repetition;\nclass RepetitionWithSeparator extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        (0, assign_1.default)(this, (0, pickBy_1.default)(options, (v) => v !== undefined));\n    }\n}\nexports.RepetitionWithSeparator = RepetitionWithSeparator;\nclass Alternation extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        this.ignoreAmbiguities = false;\n        this.hasPredicates = false;\n        (0, assign_1.default)(this, (0, pickBy_1.default)(options, (v) => v !== undefined));\n    }\n    get definition() {\n        return this._definition;\n    }\n    set definition(value) {\n        this._definition = value;\n    }\n}\nexports.Alternation = Alternation;\nclass Terminal {\n    constructor(options) {\n        this.idx = 1;\n        (0, assign_1.default)(this, (0, pickBy_1.default)(options, (v) => v !== undefined));\n    }\n    accept(visitor) {\n        visitor.visit(this);\n    }\n}\nexports.Terminal = Terminal;\nfunction serializeGrammar(topRules) {\n    return (0, map_1.default)(topRules, serializeProduction);\n}\nexports.serializeGrammar = serializeGrammar;\nfunction serializeProduction(node) {\n    function convertDefinition(definition) {\n        return (0, map_1.default)(definition, serializeProduction);\n    }\n    /* istanbul ignore else */\n    if (node instanceof NonTerminal) {\n        const serializedNonTerminal = {\n            type: \"NonTerminal\",\n            name: node.nonTerminalName,\n            idx: node.idx\n        };\n        if ((0, isString_1.default)(node.label)) {\n            serializedNonTerminal.label = node.label;\n        }\n        return serializedNonTerminal;\n    }\n    else if (node instanceof Alternative) {\n        return {\n            type: \"Alternative\",\n            definition: convertDefinition(node.definition)\n        };\n    }\n    else if (node instanceof Option) {\n        return {\n            type: \"Option\",\n            idx: node.idx,\n            definition: convertDefinition(node.definition)\n        };\n    }\n    else if (node instanceof RepetitionMandatory) {\n        return {\n            type: \"RepetitionMandatory\",\n            idx: node.idx,\n            definition: convertDefinition(node.definition)\n        };\n    }\n    else if (node instanceof RepetitionMandatoryWithSeparator) {\n        return {\n            type: \"RepetitionMandatoryWithSeparator\",\n            idx: node.idx,\n            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),\n            definition: convertDefinition(node.definition)\n        };\n    }\n    else if (node instanceof RepetitionWithSeparator) {\n        return {\n            type: \"RepetitionWithSeparator\",\n            idx: node.idx,\n            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),\n            definition: convertDefinition(node.definition)\n        };\n    }\n    else if (node instanceof Repetition) {\n        return {\n            type: \"Repetition\",\n            idx: node.idx,\n            definition: convertDefinition(node.definition)\n        };\n    }\n    else if (node instanceof Alternation) {\n        return {\n            type: \"Alternation\",\n            idx: node.idx,\n            definition: convertDefinition(node.definition)\n        };\n    }\n    else if (node instanceof Terminal) {\n        const serializedTerminal = {\n            type: \"Terminal\",\n            name: node.terminalType.name,\n            label: tokenLabel(node.terminalType),\n            idx: node.idx\n        };\n        if ((0, isString_1.default)(node.label)) {\n            serializedTerminal.terminalLabel = node.label;\n        }\n        const pattern = node.terminalType.PATTERN;\n        if (node.terminalType.PATTERN) {\n            serializedTerminal.pattern = (0, isRegExp_1.default)(pattern)\n                ? pattern.source\n                : pattern;\n        }\n        return serializedTerminal;\n    }\n    else if (node instanceof Rule) {\n        return {\n            type: \"Rule\",\n            name: node.name,\n            orgText: node.orgText,\n            definition: convertDefinition(node.definition)\n        };\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexports.serializeProduction = serializeProduction;\n//# sourceMappingURL=model.js.map"]},"metadata":{},"sourceType":"script"}