{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultGrammarValidatorErrorProvider = exports.defaultGrammarResolverErrorProvider = exports.defaultParserErrorProvider = void 0;\n\nconst tokens_public_1 = require(\"../scan/tokens_public\");\n\nconst first_1 = __importDefault(require(\"lodash/first\"));\n\nconst map_1 = __importDefault(require(\"lodash/map\"));\n\nconst reduce_1 = __importDefault(require(\"lodash/reduce\"));\n\nconst gast_1 = require(\"@chevrotain/gast\");\n\nconst gast_2 = require(\"@chevrotain/gast\");\n\nexports.defaultParserErrorProvider = {\n  buildMismatchTokenMessage({\n    expected,\n    actual,\n    previous,\n    ruleName\n  }) {\n    const hasLabel = (0, tokens_public_1.hasTokenLabel)(expected);\n    const expectedMsg = hasLabel ? `--> ${(0, tokens_public_1.tokenLabel)(expected)} <--` : `token of type --> ${expected.name} <--`;\n    const msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`;\n    return msg;\n  },\n\n  buildNotAllInputParsedMessage({\n    firstRedundant,\n    ruleName\n  }) {\n    return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n  },\n\n  buildNoViableAltMessage({\n    expectedPathsPerAlt,\n    actual,\n    previous,\n    customUserDescription,\n    ruleName\n  }) {\n    const errPrefix = \"Expecting: \"; // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n\n    const actualText = (0, first_1.default)(actual).image;\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      const allLookAheadPaths = (0, reduce_1.default)(expectedPathsPerAlt, (result, currAltPaths) => result.concat(currAltPaths), []);\n      const nextValidTokenSequences = (0, map_1.default)(allLookAheadPaths, currPath => `[${(0, map_1.default)(currPath, currTokenType => (0, tokens_public_1.tokenLabel)(currTokenType)).join(\", \")}]`);\n      const nextValidSequenceItems = (0, map_1.default)(nextValidTokenSequences, (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`);\n      const calculatedDescription = `one of these possible Token sequences:\\n${nextValidSequenceItems.join(\"\\n\")}`;\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  },\n\n  buildEarlyExitMessage({\n    expectedIterationPaths,\n    actual,\n    customUserDescription,\n    ruleName\n  }) {\n    const errPrefix = \"Expecting: \"; // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n\n    const actualText = (0, first_1.default)(actual).image;\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      const nextValidTokenSequences = (0, map_1.default)(expectedIterationPaths, currPath => `[${(0, map_1.default)(currPath, currTokenType => (0, tokens_public_1.tokenLabel)(currTokenType)).join(\",\")}]`);\n      const calculatedDescription = `expecting at least one iteration which starts with one of these possible Token sequences::\\n  ` + `<${nextValidTokenSequences.join(\" ,\")}>`;\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  }\n\n};\nObject.freeze(exports.defaultParserErrorProvider);\nexports.defaultGrammarResolverErrorProvider = {\n  buildRuleNotFoundError(topLevelRule, undefinedRule) {\n    const msg = \"Invalid grammar, reference to a rule which is not defined: ->\" + undefinedRule.nonTerminalName + \"<-\\n\" + \"inside top level rule: ->\" + topLevelRule.name + \"<-\";\n    return msg;\n  }\n\n};\nexports.defaultGrammarValidatorErrorProvider = {\n  buildDuplicateFoundError(topLevelRule, duplicateProds) {\n    function getExtraProductionArgument(prod) {\n      if (prod instanceof gast_1.Terminal) {\n        return prod.terminalType.name;\n      } else if (prod instanceof gast_1.NonTerminal) {\n        return prod.nonTerminalName;\n      } else {\n        return \"\";\n      }\n    }\n\n    const topLevelName = topLevelRule.name;\n    const duplicateProd = (0, first_1.default)(duplicateProds);\n    const index = duplicateProd.idx;\n    const dslName = (0, gast_2.getProductionDslName)(duplicateProd);\n    const extraArgument = getExtraProductionArgument(duplicateProd);\n    const hasExplicitIndex = index > 0;\n    let msg = `->${dslName}${hasExplicitIndex ? index : \"\"}<- ${extraArgument ? `with argument: ->${extraArgument}<-` : \"\"}\n                  appears more than once (${duplicateProds.length} times) in the top level rule: ->${topLevelName}<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  `; // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n\n    msg = msg.replace(/[ \\t]+/g, \" \");\n    msg = msg.replace(/\\s\\s+/g, \"\\n\");\n    return msg;\n  },\n\n  buildNamespaceConflictError(rule) {\n    const errMsg = `Namespace conflict found in grammar.\\n` + `The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.\\n` + `To resolve this make sure each Terminal and Non-Terminal names are unique\\n` + `This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n` + `and Non-Terminal names start with a lower case letter.`;\n    return errMsg;\n  },\n\n  buildAlternationPrefixAmbiguityError(options) {\n    const pathMsg = (0, map_1.default)(options.prefixPath, currTok => (0, tokens_public_1.tokenLabel)(currTok)).join(\", \");\n    const occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    const errMsg = `Ambiguous alternatives: <${options.ambiguityIndices.join(\" ,\")}> due to common lookahead prefix\\n` + `in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\\n` + `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n` + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n` + `For Further details.`;\n    return errMsg;\n  },\n\n  buildAlternationAmbiguityError(options) {\n    const pathMsg = (0, map_1.default)(options.prefixPath, currtok => (0, tokens_public_1.tokenLabel)(currtok)).join(\", \");\n    const occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\" ,\")}> in <OR${occurrence}>` + ` inside <${options.topLevelRule.name}> Rule,\\n` + `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`;\n    currMessage = currMessage + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` + `For Further details.`;\n    return currMessage;\n  },\n\n  buildEmptyRepetitionError(options) {\n    let dslName = (0, gast_2.getProductionDslName)(options.repetition);\n\n    if (options.repetition.idx !== 0) {\n      dslName += options.repetition.idx;\n    }\n\n    const errMsg = `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.\\n` + `This could lead to an infinite loop.`;\n    return errMsg;\n  },\n\n  // TODO: remove - `errors_public` from nyc.config.js exclude\n  //       once this method is fully removed from this file\n  buildTokenNameError(options) {\n    /* istanbul ignore next */\n    return \"deprecated\";\n  },\n\n  buildEmptyAlternationError(options) {\n    const errMsg = `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}>` + ` in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n` + `Only the last alternative may be an empty alternative.`;\n    return errMsg;\n  },\n\n  buildTooManyAlternativesError(options) {\n    const errMsg = `An Alternation cannot have more than 256 alternatives:\\n` + `<OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n has ${options.alternation.definition.length + 1} alternatives.`;\n    return errMsg;\n  },\n\n  buildLeftRecursionError(options) {\n    const ruleName = options.topLevelRule.name;\n    const pathNames = (0, map_1.default)(options.leftRecursionPath, currRule => currRule.name);\n    const leftRecursivePath = `${ruleName} --> ${pathNames.concat([ruleName]).join(\" --> \")}`;\n    const errMsg = `Left Recursion found in grammar.\\n` + `rule: <${ruleName}> can be invoked from itself (directly or indirectly)\\n` + `without consuming any Tokens. The grammar path that causes this is: \\n ${leftRecursivePath}\\n` + ` To fix this refactor your grammar to remove the left recursion.\\n` + `see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;\n    return errMsg;\n  },\n\n  // TODO: remove - `errors_public` from nyc.config.js exclude\n  //       once this method is fully removed from this file\n  buildInvalidRuleNameError(options) {\n    /* istanbul ignore next */\n    return \"deprecated\";\n  },\n\n  buildDuplicateRuleNameError(options) {\n    let ruleName;\n\n    if (options.topLevelRule instanceof gast_1.Rule) {\n      ruleName = options.topLevelRule.name;\n    } else {\n      ruleName = options.topLevelRule;\n    }\n\n    const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`;\n    return errMsg;\n  }\n\n};","map":{"version":3,"sources":["../../../src/parse/errors_public.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultGrammarValidatorErrorProvider = exports.defaultGrammarResolverErrorProvider = exports.defaultParserErrorProvider = void 0;\nconst tokens_public_1 = require(\"../scan/tokens_public\");\nconst first_1 = __importDefault(require(\"lodash/first\"));\nconst map_1 = __importDefault(require(\"lodash/map\"));\nconst reduce_1 = __importDefault(require(\"lodash/reduce\"));\nconst gast_1 = require(\"@chevrotain/gast\");\nconst gast_2 = require(\"@chevrotain/gast\");\nexports.defaultParserErrorProvider = {\n    buildMismatchTokenMessage({ expected, actual, previous, ruleName }) {\n        const hasLabel = (0, tokens_public_1.hasTokenLabel)(expected);\n        const expectedMsg = hasLabel\n            ? `--> ${(0, tokens_public_1.tokenLabel)(expected)} <--`\n            : `token of type --> ${expected.name} <--`;\n        const msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`;\n        return msg;\n    },\n    buildNotAllInputParsedMessage({ firstRedundant, ruleName }) {\n        return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n    },\n    buildNoViableAltMessage({ expectedPathsPerAlt, actual, previous, customUserDescription, ruleName }) {\n        const errPrefix = \"Expecting: \";\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n        const actualText = (0, first_1.default)(actual).image;\n        const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n            return errPrefix + customUserDescription + errSuffix;\n        }\n        else {\n            const allLookAheadPaths = (0, reduce_1.default)(expectedPathsPerAlt, (result, currAltPaths) => result.concat(currAltPaths), []);\n            const nextValidTokenSequences = (0, map_1.default)(allLookAheadPaths, (currPath) => `[${(0, map_1.default)(currPath, (currTokenType) => (0, tokens_public_1.tokenLabel)(currTokenType)).join(\", \")}]`);\n            const nextValidSequenceItems = (0, map_1.default)(nextValidTokenSequences, (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`);\n            const calculatedDescription = `one of these possible Token sequences:\\n${nextValidSequenceItems.join(\"\\n\")}`;\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    },\n    buildEarlyExitMessage({ expectedIterationPaths, actual, customUserDescription, ruleName }) {\n        const errPrefix = \"Expecting: \";\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n        const actualText = (0, first_1.default)(actual).image;\n        const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n            return errPrefix + customUserDescription + errSuffix;\n        }\n        else {\n            const nextValidTokenSequences = (0, map_1.default)(expectedIterationPaths, (currPath) => `[${(0, map_1.default)(currPath, (currTokenType) => (0, tokens_public_1.tokenLabel)(currTokenType)).join(\",\")}]`);\n            const calculatedDescription = `expecting at least one iteration which starts with one of these possible Token sequences::\\n  ` +\n                `<${nextValidTokenSequences.join(\" ,\")}>`;\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    }\n};\nObject.freeze(exports.defaultParserErrorProvider);\nexports.defaultGrammarResolverErrorProvider = {\n    buildRuleNotFoundError(topLevelRule, undefinedRule) {\n        const msg = \"Invalid grammar, reference to a rule which is not defined: ->\" +\n            undefinedRule.nonTerminalName +\n            \"<-\\n\" +\n            \"inside top level rule: ->\" +\n            topLevelRule.name +\n            \"<-\";\n        return msg;\n    }\n};\nexports.defaultGrammarValidatorErrorProvider = {\n    buildDuplicateFoundError(topLevelRule, duplicateProds) {\n        function getExtraProductionArgument(prod) {\n            if (prod instanceof gast_1.Terminal) {\n                return prod.terminalType.name;\n            }\n            else if (prod instanceof gast_1.NonTerminal) {\n                return prod.nonTerminalName;\n            }\n            else {\n                return \"\";\n            }\n        }\n        const topLevelName = topLevelRule.name;\n        const duplicateProd = (0, first_1.default)(duplicateProds);\n        const index = duplicateProd.idx;\n        const dslName = (0, gast_2.getProductionDslName)(duplicateProd);\n        const extraArgument = getExtraProductionArgument(duplicateProd);\n        const hasExplicitIndex = index > 0;\n        let msg = `->${dslName}${hasExplicitIndex ? index : \"\"}<- ${extraArgument ? `with argument: ->${extraArgument}<-` : \"\"}\n                  appears more than once (${duplicateProds.length} times) in the top level rule: ->${topLevelName}<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  `;\n        // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n        msg = msg.replace(/[ \\t]+/g, \" \");\n        msg = msg.replace(/\\s\\s+/g, \"\\n\");\n        return msg;\n    },\n    buildNamespaceConflictError(rule) {\n        const errMsg = `Namespace conflict found in grammar.\\n` +\n            `The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.\\n` +\n            `To resolve this make sure each Terminal and Non-Terminal names are unique\\n` +\n            `This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n` +\n            `and Non-Terminal names start with a lower case letter.`;\n        return errMsg;\n    },\n    buildAlternationPrefixAmbiguityError(options) {\n        const pathMsg = (0, map_1.default)(options.prefixPath, (currTok) => (0, tokens_public_1.tokenLabel)(currTok)).join(\", \");\n        const occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        const errMsg = `Ambiguous alternatives: <${options.ambiguityIndices.join(\" ,\")}> due to common lookahead prefix\\n` +\n            `in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\\n` +\n            `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n` +\n            `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n` +\n            `For Further details.`;\n        return errMsg;\n    },\n    buildAlternationAmbiguityError(options) {\n        const pathMsg = (0, map_1.default)(options.prefixPath, (currtok) => (0, tokens_public_1.tokenLabel)(currtok)).join(\", \");\n        const occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\" ,\")}> in <OR${occurrence}>` +\n            ` inside <${options.topLevelRule.name}> Rule,\\n` +\n            `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`;\n        currMessage =\n            currMessage +\n                `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` +\n                `For Further details.`;\n        return currMessage;\n    },\n    buildEmptyRepetitionError(options) {\n        let dslName = (0, gast_2.getProductionDslName)(options.repetition);\n        if (options.repetition.idx !== 0) {\n            dslName += options.repetition.idx;\n        }\n        const errMsg = `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.\\n` +\n            `This could lead to an infinite loop.`;\n        return errMsg;\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildTokenNameError(options) {\n        /* istanbul ignore next */\n        return \"deprecated\";\n    },\n    buildEmptyAlternationError(options) {\n        const errMsg = `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}>` +\n            ` in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n` +\n            `Only the last alternative may be an empty alternative.`;\n        return errMsg;\n    },\n    buildTooManyAlternativesError(options) {\n        const errMsg = `An Alternation cannot have more than 256 alternatives:\\n` +\n            `<OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n has ${options.alternation.definition.length + 1} alternatives.`;\n        return errMsg;\n    },\n    buildLeftRecursionError(options) {\n        const ruleName = options.topLevelRule.name;\n        const pathNames = (0, map_1.default)(options.leftRecursionPath, (currRule) => currRule.name);\n        const leftRecursivePath = `${ruleName} --> ${pathNames\n            .concat([ruleName])\n            .join(\" --> \")}`;\n        const errMsg = `Left Recursion found in grammar.\\n` +\n            `rule: <${ruleName}> can be invoked from itself (directly or indirectly)\\n` +\n            `without consuming any Tokens. The grammar path that causes this is: \\n ${leftRecursivePath}\\n` +\n            ` To fix this refactor your grammar to remove the left recursion.\\n` +\n            `see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;\n        return errMsg;\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildInvalidRuleNameError(options) {\n        /* istanbul ignore next */\n        return \"deprecated\";\n    },\n    buildDuplicateRuleNameError(options) {\n        let ruleName;\n        if (options.topLevelRule instanceof gast_1.Rule) {\n            ruleName = options.topLevelRule.name;\n        }\n        else {\n            ruleName = options.topLevelRule;\n        }\n        const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`;\n        return errMsg;\n    }\n};\n//# sourceMappingURL=errors_public.js.map"]},"metadata":{},"sourceType":"script"}