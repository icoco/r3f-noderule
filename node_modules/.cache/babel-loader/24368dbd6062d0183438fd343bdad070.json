{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildModel = void 0;\n\nconst gast_1 = require(\"@chevrotain/gast\");\n\nconst map_1 = __importDefault(require(\"lodash/map\"));\n\nconst flatten_1 = __importDefault(require(\"lodash/flatten\"));\n\nconst values_1 = __importDefault(require(\"lodash/values\"));\n\nconst some_1 = __importDefault(require(\"lodash/some\"));\n\nconst groupBy_1 = __importDefault(require(\"lodash/groupBy\"));\n\nconst assign_1 = __importDefault(require(\"lodash/assign\"));\n\nfunction buildModel(productions) {\n  const generator = new CstNodeDefinitionGenerator();\n  const allRules = (0, values_1.default)(productions);\n  return (0, map_1.default)(allRules, rule => generator.visitRule(rule));\n}\n\nexports.buildModel = buildModel;\n\nclass CstNodeDefinitionGenerator extends gast_1.GAstVisitor {\n  visitRule(node) {\n    const rawElements = this.visitEach(node.definition);\n    const grouped = (0, groupBy_1.default)(rawElements, el => el.propertyName);\n    const properties = (0, map_1.default)(grouped, (group, propertyName) => {\n      const allNullable = !(0, some_1.default)(group, el => !el.canBeNull); // In an alternation with a label a property name can have\n      // multiple types.\n\n      let propertyType = group[0].type;\n\n      if (group.length > 1) {\n        propertyType = (0, map_1.default)(group, g => g.type);\n      }\n\n      return {\n        name: propertyName,\n        type: propertyType,\n        optional: allNullable\n      };\n    });\n    return {\n      name: node.name,\n      properties: properties\n    };\n  }\n\n  visitAlternative(node) {\n    return this.visitEachAndOverrideWith(node.definition, {\n      canBeNull: true\n    });\n  }\n\n  visitOption(node) {\n    return this.visitEachAndOverrideWith(node.definition, {\n      canBeNull: true\n    });\n  }\n\n  visitRepetition(node) {\n    return this.visitEachAndOverrideWith(node.definition, {\n      canBeNull: true\n    });\n  }\n\n  visitRepetitionMandatory(node) {\n    return this.visitEach(node.definition);\n  }\n\n  visitRepetitionMandatoryWithSeparator(node) {\n    return this.visitEach(node.definition).concat({\n      propertyName: node.separator.name,\n      canBeNull: true,\n      type: getType(node.separator)\n    });\n  }\n\n  visitRepetitionWithSeparator(node) {\n    return this.visitEachAndOverrideWith(node.definition, {\n      canBeNull: true\n    }).concat({\n      propertyName: node.separator.name,\n      canBeNull: true,\n      type: getType(node.separator)\n    });\n  }\n\n  visitAlternation(node) {\n    return this.visitEachAndOverrideWith(node.definition, {\n      canBeNull: true\n    });\n  }\n\n  visitTerminal(node) {\n    return [{\n      propertyName: node.label || node.terminalType.name,\n      canBeNull: false,\n      type: getType(node)\n    }];\n  }\n\n  visitNonTerminal(node) {\n    return [{\n      propertyName: node.label || node.nonTerminalName,\n      canBeNull: false,\n      type: getType(node)\n    }];\n  }\n\n  visitEachAndOverrideWith(definition, override) {\n    return (0, map_1.default)(this.visitEach(definition), definition => (0, assign_1.default)({}, definition, override));\n  }\n\n  visitEach(definition) {\n    return (0, flatten_1.default)((0, map_1.default)(definition, definition => this.visit(definition)));\n  }\n\n}\n\nfunction getType(production) {\n  if (production instanceof gast_1.NonTerminal) {\n    return {\n      kind: \"rule\",\n      name: production.referencedRule.name\n    };\n  }\n\n  return {\n    kind: \"token\"\n  };\n}","map":{"version":3,"sources":["../../src/model.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buildModel = void 0;\nconst gast_1 = require(\"@chevrotain/gast\");\nconst map_1 = __importDefault(require(\"lodash/map\"));\nconst flatten_1 = __importDefault(require(\"lodash/flatten\"));\nconst values_1 = __importDefault(require(\"lodash/values\"));\nconst some_1 = __importDefault(require(\"lodash/some\"));\nconst groupBy_1 = __importDefault(require(\"lodash/groupBy\"));\nconst assign_1 = __importDefault(require(\"lodash/assign\"));\nfunction buildModel(productions) {\n    const generator = new CstNodeDefinitionGenerator();\n    const allRules = (0, values_1.default)(productions);\n    return (0, map_1.default)(allRules, (rule) => generator.visitRule(rule));\n}\nexports.buildModel = buildModel;\nclass CstNodeDefinitionGenerator extends gast_1.GAstVisitor {\n    visitRule(node) {\n        const rawElements = this.visitEach(node.definition);\n        const grouped = (0, groupBy_1.default)(rawElements, (el) => el.propertyName);\n        const properties = (0, map_1.default)(grouped, (group, propertyName) => {\n            const allNullable = !(0, some_1.default)(group, (el) => !el.canBeNull);\n            // In an alternation with a label a property name can have\n            // multiple types.\n            let propertyType = group[0].type;\n            if (group.length > 1) {\n                propertyType = (0, map_1.default)(group, (g) => g.type);\n            }\n            return {\n                name: propertyName,\n                type: propertyType,\n                optional: allNullable\n            };\n        });\n        return {\n            name: node.name,\n            properties: properties\n        };\n    }\n    visitAlternative(node) {\n        return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });\n    }\n    visitOption(node) {\n        return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });\n    }\n    visitRepetition(node) {\n        return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });\n    }\n    visitRepetitionMandatory(node) {\n        return this.visitEach(node.definition);\n    }\n    visitRepetitionMandatoryWithSeparator(node) {\n        return this.visitEach(node.definition).concat({\n            propertyName: node.separator.name,\n            canBeNull: true,\n            type: getType(node.separator)\n        });\n    }\n    visitRepetitionWithSeparator(node) {\n        return this.visitEachAndOverrideWith(node.definition, {\n            canBeNull: true\n        }).concat({\n            propertyName: node.separator.name,\n            canBeNull: true,\n            type: getType(node.separator)\n        });\n    }\n    visitAlternation(node) {\n        return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });\n    }\n    visitTerminal(node) {\n        return [\n            {\n                propertyName: node.label || node.terminalType.name,\n                canBeNull: false,\n                type: getType(node)\n            }\n        ];\n    }\n    visitNonTerminal(node) {\n        return [\n            {\n                propertyName: node.label || node.nonTerminalName,\n                canBeNull: false,\n                type: getType(node)\n            }\n        ];\n    }\n    visitEachAndOverrideWith(definition, override) {\n        return (0, map_1.default)(this.visitEach(definition), (definition) => (0, assign_1.default)({}, definition, override));\n    }\n    visitEach(definition) {\n        return (0, flatten_1.default)((0, map_1.default)(definition, (definition) => this.visit(definition)));\n    }\n}\nfunction getType(production) {\n    if (production instanceof gast_1.NonTerminal) {\n        return {\n            kind: \"rule\",\n            name: production.referencedRule.name\n        };\n    }\n    return { kind: \"token\" };\n}\n//# sourceMappingURL=model.js.map"]},"metadata":{},"sourceType":"script"}