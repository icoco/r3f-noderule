{"ast":null,"code":"import { useComposedRefs as e } from \"@radix-ui/react-compose-refs\";\nimport * as n from \"react\";\nexport const Presence = r => {\n  const {\n    present: u,\n    children: o\n  } = r,\n        s = function (e) {\n    const [r, u] = n.useState(),\n          o = n.useRef({}),\n          s = n.useRef(e),\n          i = n.useRef(),\n          c = e ? \"mounted\" : \"unmounted\",\n          [a, d] = function (e, t) {\n      return n.useReducer((e, n) => {\n        const r = t[e][n];\n        return null != r ? r : e;\n      }, e);\n    }(c, {\n      mounted: {\n        UNMOUNT: \"unmounted\",\n        ANIMATION_OUT: \"unmountSuspended\"\n      },\n      unmountSuspended: {\n        MOUNT: \"mounted\",\n        ANIMATION_END: \"unmounted\"\n      },\n      unmounted: {\n        MOUNT: \"mounted\"\n      }\n    });\n\n    return n.useEffect(() => {\n      const n = o.current,\n            r = s.current;\n\n      if (r !== e) {\n        const u = i.current,\n              o = t(n);\n        if (e) d(\"MOUNT\");else if (\"none\" === o || \"none\" === (null == n ? void 0 : n.display)) d(\"UNMOUNT\");else {\n          const e = u !== o;\n          d(r && e ? \"ANIMATION_OUT\" : \"UNMOUNT\");\n        }\n        s.current = e;\n      }\n    }, [e, d]), n.useEffect(() => {\n      if (r) {\n        const e = e => {\n          const n = t(o.current).includes(e.animationName);\n          e.target === r && n && d(\"ANIMATION_END\");\n        },\n              n = e => {\n          e.target === r && (i.current = t(o.current));\n        };\n\n        return r.addEventListener(\"animationstart\", n), r.addEventListener(\"animationcancel\", e), r.addEventListener(\"animationend\", e), () => {\n          r.removeEventListener(\"animationstart\", n), r.removeEventListener(\"animationcancel\", e), r.removeEventListener(\"animationend\", e);\n        };\n      }\n    }, [r, d]), {\n      isPresent: [\"mounted\", \"unmountSuspended\"].includes(a),\n      ref: n.useCallback(e => {\n        e && (o.current = getComputedStyle(e), u(e));\n      }, [])\n    };\n  }(u),\n        i = \"function\" == typeof o ? o({\n    present: s.isPresent\n  }) : n.Children.only(o),\n        c = e(s.ref, i.ref);\n\n  return \"function\" == typeof o || s.isPresent ? /*#__PURE__*/n.cloneElement(i, {\n    ref: c\n  }) : null;\n};\n\nfunction t(e) {\n  return (null == e ? void 0 : e.animationName) || \"none\";\n}\n\nPresence.displayName = \"Presence\";","map":{"version":3,"sources":["packages/react/presence/src/Presence.tsx","packages/react/presence/src/useStateMachine.tsx"],"names":["Presence","props","present","children","presence","usePresence","child","isPresent","React","Children","only","ref","useComposedRefs","cloneElement","displayName","node","setNode","useState","stylesRef","useRef","prevPresentRef","prevAnimationNameRef","initialState","state","send","$d88c0747af12355025ed3195fb48c68a$export$useStateMachine","mounted","UNMOUNT","ANIMATION_OUT","unmountSuspended","MOUNT","ANIMATION_END","unmounted","useEffect","styles","current","wasPresent","prevAnimationName","currentAnimationName","getAnimationName","display","isAnimating","handleAnimationEnd","event","isCurrentAnimation","includes","animationName","target","handleAnimationStart","addEventListener","removeEventListener","useCallback","getComputedStyle","machine","useReducer","nextState"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useStateMachine } from './useStateMachine';\n\ntype PresenceProps = {\n  present: boolean;\n  children: React.ReactElement | ((props: { present: boolean }) => React.ReactElement);\n};\n\nconst Presence: React.FC<PresenceProps> = (props) => {\n  const { present, children } = props;\n  const presence = usePresence(present);\n\n  const child = (typeof children === 'function'\n    ? children({ present: presence.isPresent })\n    : React.Children.only(children)) as React.ReactElement;\n\n  const ref = useComposedRefs(presence.ref, (child as any).ref);\n  const forceMount = typeof children === 'function';\n  return forceMount || presence.isPresent ? React.cloneElement(child, { ref }) : null;\n};\n\nPresence.displayName = 'Presence';\n\n/* -------------------------------------------------------------------------------------------------\n * usePresence\n * -----------------------------------------------------------------------------------------------*/\n\nfunction usePresence(present: boolean) {\n  const [node, setNode] = React.useState<HTMLElement>();\n  const stylesRef = React.useRef<CSSStyleDeclaration>({} as any);\n  const prevPresentRef = React.useRef(present);\n  const prevAnimationNameRef = React.useRef<string>();\n  const initialState = present ? 'mounted' : 'unmounted';\n  const [state, send] = useStateMachine(initialState, {\n    mounted: {\n      UNMOUNT: 'unmounted',\n      ANIMATION_OUT: 'unmountSuspended',\n    },\n    unmountSuspended: {\n      MOUNT: 'mounted',\n      ANIMATION_END: 'unmounted',\n    },\n    unmounted: {\n      MOUNT: 'mounted',\n    },\n  });\n\n  React.useEffect(() => {\n    const styles = stylesRef.current;\n    const wasPresent = prevPresentRef.current;\n    const hasPresentChanged = wasPresent !== present;\n\n    if (hasPresentChanged) {\n      const prevAnimationName = prevAnimationNameRef.current;\n      const currentAnimationName = getAnimationName(styles);\n\n      if (present) {\n        send('MOUNT');\n      } else if (currentAnimationName === 'none' || styles?.display === 'none') {\n        // If there is no exit animation or the element is hidden, animations won't run\n        // so we unmount instantly\n        send('UNMOUNT');\n      } else {\n        /**\n         * When `present` changes to `false`, we check changes to animation-name to\n         * determine whether an animation has started. We chose this approach (reading\n         * computed styles) because there is no `animationrun` event and `animationstart`\n         * fires after `animation-delay` has expired which would be too late.\n         */\n        const isAnimating = prevAnimationName !== currentAnimationName;\n\n        if (wasPresent && isAnimating) {\n          send('ANIMATION_OUT');\n        } else {\n          send('UNMOUNT');\n        }\n      }\n\n      prevPresentRef.current = present;\n    }\n  }, [present, send]);\n\n  React.useEffect(() => {\n    if (node) {\n      /**\n       * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`\n       * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we\n       * make sure we only trigger ANIMATION_END for the currently active animation.\n       */\n      const handleAnimationEnd = (event: AnimationEvent) => {\n        const currentAnimationName = getAnimationName(stylesRef.current);\n        const isCurrentAnimation = currentAnimationName.includes(event.animationName);\n        if (event.target === node && isCurrentAnimation) {\n          send('ANIMATION_END');\n        }\n      };\n\n      const handleAnimationStart = (event: AnimationEvent) => {\n        if (event.target === node) {\n          // if animation occurred, store its name as the previous animation.\n          prevAnimationNameRef.current = getAnimationName(stylesRef.current);\n        }\n      };\n\n      node.addEventListener('animationstart', handleAnimationStart);\n      node.addEventListener('animationcancel', handleAnimationEnd);\n      node.addEventListener('animationend', handleAnimationEnd);\n\n      return () => {\n        node.removeEventListener('animationstart', handleAnimationStart);\n        node.removeEventListener('animationcancel', handleAnimationEnd);\n        node.removeEventListener('animationend', handleAnimationEnd);\n      };\n    }\n  }, [node, send]);\n\n  return {\n    isPresent: ['mounted', 'unmountSuspended'].includes(state),\n    ref: React.useCallback((node: HTMLElement) => {\n      if (node) {\n        stylesRef.current = getComputedStyle(node);\n        setNode(node);\n      }\n    }, []),\n  };\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getAnimationName(styles?: CSSStyleDeclaration) {\n  return styles?.animationName || 'none';\n}\n\nexport { Presence };\n","import * as React from 'react';\n\ntype Machine<S> = { [k: string]: { [k: string]: S } };\ntype MachineState<T> = keyof T;\ntype MachineEvent<T> = keyof UnionToIntersection<T[keyof T]>;\n\n// ðŸ¤¯ https://fettblog.eu/typescript-union-to-intersection/\ntype UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any\n  ? R\n  : never;\n\nexport function useStateMachine<M>(\n  initialState: MachineState<M>,\n  machine: M & Machine<MachineState<M>>\n) {\n  return React.useReducer((state: MachineState<M>, event: MachineEvent<M>): MachineState<M> => {\n    const nextState = (machine[state] as any)[event];\n    return nextState ?? state;\n  }, initialState);\n}\n"]},"metadata":{},"sourceType":"module"}