{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.collectMethods = exports.LooksAhead = void 0;\n\nconst lookahead_1 = require(\"../../grammar/lookahead\");\n\nconst forEach_1 = __importDefault(require(\"lodash/forEach\"));\n\nconst has_1 = __importDefault(require(\"lodash/has\"));\n\nconst parser_1 = require(\"../parser\");\n\nconst keys_1 = require(\"../../grammar/keys\");\n\nconst gast_1 = require(\"@chevrotain/gast\");\n\nconst gast_2 = require(\"@chevrotain/gast\");\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\n\n\nclass LooksAhead {\n  initLooksAhead(config) {\n    this.dynamicTokensEnabled = (0, has_1.default)(config, \"dynamicTokensEnabled\") ? config.dynamicTokensEnabled // assumes end user provides the correct config value/type\n    : parser_1.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;\n    this.maxLookahead = (0, has_1.default)(config, \"maxLookahead\") ? config.maxLookahead // assumes end user provides the correct config value/type\n    : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;\n    this.lookAheadFuncsCache = new Map();\n  }\n\n  preComputeLookaheadFunctions(rules) {\n    (0, forEach_1.default)(rules, currRule => {\n      this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {\n        const {\n          alternation,\n          repetition,\n          option,\n          repetitionMandatory,\n          repetitionMandatoryWithSeparator,\n          repetitionWithSeparator\n        } = collectMethods(currRule);\n        (0, forEach_1.default)(alternation, currProd => {\n          const prodIdx = currProd.idx === 0 ? \"\" : currProd.idx;\n          this.TRACE_INIT(`${(0, gast_2.getProductionDslName)(currProd)}${prodIdx}`, () => {\n            const laFunc = (0, lookahead_1.buildLookaheadFuncForOr)(currProd.idx, currRule, currProd.maxLookahead || this.maxLookahead, currProd.hasPredicates, this.dynamicTokensEnabled, this.lookAheadBuilderForAlternatives);\n            const key = (0, keys_1.getKeyForAutomaticLookahead)(this.fullRuleNameToShort[currRule.name], keys_1.OR_IDX, currProd.idx);\n            this.setLaFuncCache(key, laFunc);\n          });\n        });\n        (0, forEach_1.default)(repetition, currProd => {\n          this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_IDX, lookahead_1.PROD_TYPE.REPETITION, currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n        });\n        (0, forEach_1.default)(option, currProd => {\n          this.computeLookaheadFunc(currRule, currProd.idx, keys_1.OPTION_IDX, lookahead_1.PROD_TYPE.OPTION, currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n        });\n        (0, forEach_1.default)(repetitionMandatory, currProd => {\n          this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_IDX, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n        });\n        (0, forEach_1.default)(repetitionMandatoryWithSeparator, currProd => {\n          this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_SEP_IDX, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n        });\n        (0, forEach_1.default)(repetitionWithSeparator, currProd => {\n          this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_SEP_IDX, lookahead_1.PROD_TYPE.REPETITION_WITH_SEPARATOR, currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n        });\n      });\n    });\n  }\n\n  computeLookaheadFunc(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {\n    this.TRACE_INIT(`${dslMethodName}${prodOccurrence === 0 ? \"\" : prodOccurrence}`, () => {\n      const laFunc = (0, lookahead_1.buildLookaheadFuncForOptionalProd)(prodOccurrence, rule, prodMaxLookahead || this.maxLookahead, this.dynamicTokensEnabled, prodType, this.lookAheadBuilderForOptional);\n      const key = (0, keys_1.getKeyForAutomaticLookahead)(this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);\n      this.setLaFuncCache(key, laFunc);\n    });\n  }\n\n  lookAheadBuilderForOptional(alt, tokenMatcher, dynamicTokensEnabled) {\n    return (0, lookahead_1.buildSingleAlternativeLookaheadFunction)(alt, tokenMatcher, dynamicTokensEnabled);\n  }\n\n  lookAheadBuilderForAlternatives(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n    return (0, lookahead_1.buildAlternativesLookAheadFunc)(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n  } // this actually returns a number, but it is always used as a string (object prop key)\n\n\n  getKeyForAutomaticLookahead(dslMethodIdx, occurrence) {\n    const currRuleShortName = this.getLastExplicitRuleShortName();\n    return (0, keys_1.getKeyForAutomaticLookahead)(currRuleShortName, dslMethodIdx, occurrence);\n  }\n\n  getLaFuncFromCache(key) {\n    return this.lookAheadFuncsCache.get(key);\n  }\n  /* istanbul ignore next */\n\n\n  setLaFuncCache(key, value) {\n    this.lookAheadFuncsCache.set(key, value);\n  }\n\n}\n\nexports.LooksAhead = LooksAhead;\n\nclass DslMethodsCollectorVisitor extends gast_1.GAstVisitor {\n  constructor() {\n    super(...arguments);\n    this.dslMethods = {\n      option: [],\n      alternation: [],\n      repetition: [],\n      repetitionWithSeparator: [],\n      repetitionMandatory: [],\n      repetitionMandatoryWithSeparator: []\n    };\n  }\n\n  reset() {\n    this.dslMethods = {\n      option: [],\n      alternation: [],\n      repetition: [],\n      repetitionWithSeparator: [],\n      repetitionMandatory: [],\n      repetitionMandatoryWithSeparator: []\n    };\n  }\n\n  visitOption(option) {\n    this.dslMethods.option.push(option);\n  }\n\n  visitRepetitionWithSeparator(manySep) {\n    this.dslMethods.repetitionWithSeparator.push(manySep);\n  }\n\n  visitRepetitionMandatory(atLeastOne) {\n    this.dslMethods.repetitionMandatory.push(atLeastOne);\n  }\n\n  visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n    this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);\n  }\n\n  visitRepetition(many) {\n    this.dslMethods.repetition.push(many);\n  }\n\n  visitAlternation(or) {\n    this.dslMethods.alternation.push(or);\n  }\n\n}\n\nconst collectorVisitor = new DslMethodsCollectorVisitor();\n\nfunction collectMethods(rule) {\n  collectorVisitor.reset();\n  rule.accept(collectorVisitor);\n  const dslMethods = collectorVisitor.dslMethods; // avoid uncleaned references\n\n  collectorVisitor.reset();\n  return dslMethods;\n}\n\nexports.collectMethods = collectMethods;","map":{"version":3,"sources":["../../../../../src/parse/parser/traits/looksahead.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.collectMethods = exports.LooksAhead = void 0;\nconst lookahead_1 = require(\"../../grammar/lookahead\");\nconst forEach_1 = __importDefault(require(\"lodash/forEach\"));\nconst has_1 = __importDefault(require(\"lodash/has\"));\nconst parser_1 = require(\"../parser\");\nconst keys_1 = require(\"../../grammar/keys\");\nconst gast_1 = require(\"@chevrotain/gast\");\nconst gast_2 = require(\"@chevrotain/gast\");\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\nclass LooksAhead {\n    initLooksAhead(config) {\n        this.dynamicTokensEnabled = (0, has_1.default)(config, \"dynamicTokensEnabled\")\n            ? config.dynamicTokensEnabled // assumes end user provides the correct config value/type\n            : parser_1.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;\n        this.maxLookahead = (0, has_1.default)(config, \"maxLookahead\")\n            ? config.maxLookahead // assumes end user provides the correct config value/type\n            : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;\n        this.lookAheadFuncsCache = new Map();\n    }\n    preComputeLookaheadFunctions(rules) {\n        (0, forEach_1.default)(rules, (currRule) => {\n            this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {\n                const { alternation, repetition, option, repetitionMandatory, repetitionMandatoryWithSeparator, repetitionWithSeparator } = collectMethods(currRule);\n                (0, forEach_1.default)(alternation, (currProd) => {\n                    const prodIdx = currProd.idx === 0 ? \"\" : currProd.idx;\n                    this.TRACE_INIT(`${(0, gast_2.getProductionDslName)(currProd)}${prodIdx}`, () => {\n                        const laFunc = (0, lookahead_1.buildLookaheadFuncForOr)(currProd.idx, currRule, currProd.maxLookahead || this.maxLookahead, currProd.hasPredicates, this.dynamicTokensEnabled, this.lookAheadBuilderForAlternatives);\n                        const key = (0, keys_1.getKeyForAutomaticLookahead)(this.fullRuleNameToShort[currRule.name], keys_1.OR_IDX, currProd.idx);\n                        this.setLaFuncCache(key, laFunc);\n                    });\n                });\n                (0, forEach_1.default)(repetition, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_IDX, lookahead_1.PROD_TYPE.REPETITION, currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n                });\n                (0, forEach_1.default)(option, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, keys_1.OPTION_IDX, lookahead_1.PROD_TYPE.OPTION, currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n                });\n                (0, forEach_1.default)(repetitionMandatory, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_IDX, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n                });\n                (0, forEach_1.default)(repetitionMandatoryWithSeparator, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_SEP_IDX, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n                });\n                (0, forEach_1.default)(repetitionWithSeparator, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_SEP_IDX, lookahead_1.PROD_TYPE.REPETITION_WITH_SEPARATOR, currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n                });\n            });\n        });\n    }\n    computeLookaheadFunc(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {\n        this.TRACE_INIT(`${dslMethodName}${prodOccurrence === 0 ? \"\" : prodOccurrence}`, () => {\n            const laFunc = (0, lookahead_1.buildLookaheadFuncForOptionalProd)(prodOccurrence, rule, prodMaxLookahead || this.maxLookahead, this.dynamicTokensEnabled, prodType, this.lookAheadBuilderForOptional);\n            const key = (0, keys_1.getKeyForAutomaticLookahead)(this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);\n            this.setLaFuncCache(key, laFunc);\n        });\n    }\n    lookAheadBuilderForOptional(alt, tokenMatcher, dynamicTokensEnabled) {\n        return (0, lookahead_1.buildSingleAlternativeLookaheadFunction)(alt, tokenMatcher, dynamicTokensEnabled);\n    }\n    lookAheadBuilderForAlternatives(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n        return (0, lookahead_1.buildAlternativesLookAheadFunc)(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n    }\n    // this actually returns a number, but it is always used as a string (object prop key)\n    getKeyForAutomaticLookahead(dslMethodIdx, occurrence) {\n        const currRuleShortName = this.getLastExplicitRuleShortName();\n        return (0, keys_1.getKeyForAutomaticLookahead)(currRuleShortName, dslMethodIdx, occurrence);\n    }\n    getLaFuncFromCache(key) {\n        return this.lookAheadFuncsCache.get(key);\n    }\n    /* istanbul ignore next */\n    setLaFuncCache(key, value) {\n        this.lookAheadFuncsCache.set(key, value);\n    }\n}\nexports.LooksAhead = LooksAhead;\nclass DslMethodsCollectorVisitor extends gast_1.GAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.dslMethods = {\n            option: [],\n            alternation: [],\n            repetition: [],\n            repetitionWithSeparator: [],\n            repetitionMandatory: [],\n            repetitionMandatoryWithSeparator: []\n        };\n    }\n    reset() {\n        this.dslMethods = {\n            option: [],\n            alternation: [],\n            repetition: [],\n            repetitionWithSeparator: [],\n            repetitionMandatory: [],\n            repetitionMandatoryWithSeparator: []\n        };\n    }\n    visitOption(option) {\n        this.dslMethods.option.push(option);\n    }\n    visitRepetitionWithSeparator(manySep) {\n        this.dslMethods.repetitionWithSeparator.push(manySep);\n    }\n    visitRepetitionMandatory(atLeastOne) {\n        this.dslMethods.repetitionMandatory.push(atLeastOne);\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n        this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);\n    }\n    visitRepetition(many) {\n        this.dslMethods.repetition.push(many);\n    }\n    visitAlternation(or) {\n        this.dslMethods.alternation.push(or);\n    }\n}\nconst collectorVisitor = new DslMethodsCollectorVisitor();\nfunction collectMethods(rule) {\n    collectorVisitor.reset();\n    rule.accept(collectorVisitor);\n    const dslMethods = collectorVisitor.dslMethods;\n    // avoid uncleaned references\n    collectorVisitor.reset();\n    return dslMethods;\n}\nexports.collectMethods = collectMethods;\n//# sourceMappingURL=looksahead.js.map"]},"metadata":{},"sourceType":"script"}