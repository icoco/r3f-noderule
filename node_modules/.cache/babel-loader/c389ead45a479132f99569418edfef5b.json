{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.attemptInRepetitionRecovery = exports.Recoverable = exports.InRuleRecoveryException = exports.IN_RULE_RECOVERY_EXCEPTION = exports.EOF_FOLLOW_KEY = void 0;\n\nconst tokens_public_1 = require(\"../../../scan/tokens_public\");\n\nconst isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\n\nconst dropRight_1 = __importDefault(require(\"lodash/dropRight\"));\n\nconst flatten_1 = __importDefault(require(\"lodash/flatten\"));\n\nconst map_1 = __importDefault(require(\"lodash/map\"));\n\nconst find_1 = __importDefault(require(\"lodash/find\"));\n\nconst has_1 = __importDefault(require(\"lodash/has\"));\n\nconst includes_1 = __importDefault(require(\"lodash/includes\"));\n\nconst clone_1 = __importDefault(require(\"lodash/clone\"));\n\nconst exceptions_public_1 = require(\"../../exceptions_public\");\n\nconst constants_1 = require(\"../../constants\");\n\nconst parser_1 = require(\"../parser\");\n\nexports.EOF_FOLLOW_KEY = {};\nexports.IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\n\nclass InRuleRecoveryException extends Error {\n  constructor(message) {\n    super(message);\n    this.name = exports.IN_RULE_RECOVERY_EXCEPTION;\n  }\n\n}\n\nexports.InRuleRecoveryException = InRuleRecoveryException;\n/**\n * This trait is responsible for the error recovery and fault tolerant logic\n */\n\nclass Recoverable {\n  initRecoverable(config) {\n    this.firstAfterRepMap = {};\n    this.resyncFollows = {};\n    this.recoveryEnabled = (0, has_1.default)(config, \"recoveryEnabled\") ? config.recoveryEnabled // assumes end user provides the correct config value/type\n    : parser_1.DEFAULT_PARSER_CONFIG.recoveryEnabled; // performance optimization, NOOP will be inlined which\n    // effectively means that this optional feature does not exist\n    // when not used.\n\n    if (this.recoveryEnabled) {\n      this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n    }\n  }\n\n  getTokenToInsert(tokType) {\n    const tokToInsert = (0, tokens_public_1.createTokenInstance)(tokType, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n    tokToInsert.isInsertedInRecovery = true;\n    return tokToInsert;\n  }\n\n  canTokenTypeBeInsertedInRecovery(tokType) {\n    return true;\n  }\n\n  canTokenTypeBeDeletedInRecovery(tokType) {\n    return true;\n  }\n\n  tryInRepetitionRecovery(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n    // TODO: can the resyncTokenType be cached?\n    const reSyncTokType = this.findReSyncTokenType();\n    const savedLexerState = this.exportLexerState();\n    const resyncedTokens = [];\n    let passedResyncPoint = false;\n    const nextTokenWithoutResync = this.LA(1);\n    let currToken = this.LA(1);\n\n    const generateErrorMessage = () => {\n      const previousToken = this.LA(0); // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n      // the error that would have been thrown\n\n      const msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: expectedTokType,\n        actual: nextTokenWithoutResync,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName()\n      });\n      const error = new exceptions_public_1.MismatchedTokenException(msg, nextTokenWithoutResync, this.LA(0)); // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n\n      error.resyncedTokens = (0, dropRight_1.default)(resyncedTokens);\n      this.SAVE_ERROR(error);\n    };\n\n    while (!passedResyncPoint) {\n      // re-synced to a point where we can safely exit the repetition/\n      if (this.tokenMatcher(currToken, expectedTokType)) {\n        generateErrorMessage();\n        return; // must return here to avoid reverting the inputIdx\n      } else if (lookAheadFunc.call(this)) {\n        // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n        generateErrorMessage(); // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n\n        grammarRule.apply(this, grammarRuleArgs);\n        return; // must return here to avoid reverting the inputIdx\n      } else if (this.tokenMatcher(currToken, reSyncTokType)) {\n        passedResyncPoint = true;\n      } else {\n        currToken = this.SKIP_TOKEN();\n        this.addToResyncTokens(currToken, resyncedTokens);\n      }\n    } // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n    // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n    // \"between rules\" resync recovery later in the flow.\n\n\n    this.importLexerState(savedLexerState);\n  }\n\n  shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck) {\n    // Edge case of arriving from a MANY repetition which is stuck\n    // Attempting recovery in this case could cause an infinite loop\n    if (notStuck === false) {\n      return false;\n    } // no need to recover, next token is what we expect...\n\n\n    if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n      return false;\n    } // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n    // and prefer some backtracking path that includes recovered errors.\n\n\n    if (this.isBackTracking()) {\n      return false;\n    } // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n    // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n    //noinspection RedundantIfStatementJS\n\n\n    if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\n      return false;\n    }\n\n    return true;\n  } // Error Recovery functionality\n\n\n  getFollowsForInRuleRecovery(tokType, tokIdxInRule) {\n    const grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n    const follows = this.getNextPossibleTokenTypes(grammarPath);\n    return follows;\n  }\n\n  tryInRuleRecovery(expectedTokType, follows) {\n    if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n      const tokToInsert = this.getTokenToInsert(expectedTokType);\n      return tokToInsert;\n    }\n\n    if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n      const nextTok = this.SKIP_TOKEN();\n      this.consumeToken();\n      return nextTok;\n    }\n\n    throw new InRuleRecoveryException(\"sad sad panda\");\n  }\n\n  canPerformInRuleRecovery(expectedToken, follows) {\n    return this.canRecoverWithSingleTokenInsertion(expectedToken, follows) || this.canRecoverWithSingleTokenDeletion(expectedToken);\n  }\n\n  canRecoverWithSingleTokenInsertion(expectedTokType, follows) {\n    if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n      return false;\n    } // must know the possible following tokens to perform single token insertion\n\n\n    if ((0, isEmpty_1.default)(follows)) {\n      return false;\n    }\n\n    const mismatchedTok = this.LA(1);\n    const isMisMatchedTokInFollows = (0, find_1.default)(follows, possibleFollowsTokType => {\n      return this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n    }) !== undefined;\n    return isMisMatchedTokInFollows;\n  }\n\n  canRecoverWithSingleTokenDeletion(expectedTokType) {\n    if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {\n      return false;\n    }\n\n    const isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n    return isNextTokenWhatIsExpected;\n  }\n\n  isInCurrentRuleReSyncSet(tokenTypeIdx) {\n    const followKey = this.getCurrFollowKey();\n    const currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n    return (0, includes_1.default)(currentRuleReSyncSet, tokenTypeIdx);\n  }\n\n  findReSyncTokenType() {\n    const allPossibleReSyncTokTypes = this.flattenFollowSet(); // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n\n    let nextToken = this.LA(1);\n    let k = 2;\n\n    while (true) {\n      const foundMatch = (0, find_1.default)(allPossibleReSyncTokTypes, resyncTokType => {\n        const canMatch = (0, tokens_public_1.tokenMatcher)(nextToken, resyncTokType);\n        return canMatch;\n      });\n\n      if (foundMatch !== undefined) {\n        return foundMatch;\n      }\n\n      nextToken = this.LA(k);\n      k++;\n    }\n  }\n\n  getCurrFollowKey() {\n    // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n    if (this.RULE_STACK.length === 1) {\n      return exports.EOF_FOLLOW_KEY;\n    }\n\n    const currRuleShortName = this.getLastExplicitRuleShortName();\n    const currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n    const prevRuleShortName = this.getPreviousExplicitRuleShortName();\n    return {\n      ruleName: this.shortRuleNameToFullName(currRuleShortName),\n      idxInCallingRule: currRuleIdx,\n      inRule: this.shortRuleNameToFullName(prevRuleShortName)\n    };\n  }\n\n  buildFullFollowKeyStack() {\n    const explicitRuleStack = this.RULE_STACK;\n    const explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n    return (0, map_1.default)(explicitRuleStack, (ruleName, idx) => {\n      if (idx === 0) {\n        return exports.EOF_FOLLOW_KEY;\n      }\n\n      return {\n        ruleName: this.shortRuleNameToFullName(ruleName),\n        idxInCallingRule: explicitOccurrenceStack[idx],\n        inRule: this.shortRuleNameToFullName(explicitRuleStack[idx - 1])\n      };\n    });\n  }\n\n  flattenFollowSet() {\n    const followStack = (0, map_1.default)(this.buildFullFollowKeyStack(), currKey => {\n      return this.getFollowSetFromFollowKey(currKey);\n    });\n    return (0, flatten_1.default)(followStack);\n  }\n\n  getFollowSetFromFollowKey(followKey) {\n    if (followKey === exports.EOF_FOLLOW_KEY) {\n      return [tokens_public_1.EOF];\n    }\n\n    const followName = followKey.ruleName + followKey.idxInCallingRule + constants_1.IN + followKey.inRule;\n    return this.resyncFollows[followName];\n  } // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n  // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n\n\n  addToResyncTokens(token, resyncTokens) {\n    if (!this.tokenMatcher(token, tokens_public_1.EOF)) {\n      resyncTokens.push(token);\n    }\n\n    return resyncTokens;\n  }\n\n  reSyncTo(tokType) {\n    const resyncedTokens = [];\n    let nextTok = this.LA(1);\n\n    while (this.tokenMatcher(nextTok, tokType) === false) {\n      nextTok = this.SKIP_TOKEN();\n      this.addToResyncTokens(nextTok, resyncedTokens);\n    } // the last token is not part of the error.\n\n\n    return (0, dropRight_1.default)(resyncedTokens);\n  }\n\n  attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {// by default this is a NO-OP\n    // The actual implementation is with the function(not method) below\n  }\n\n  getCurrentGrammarPath(tokType, tokIdxInRule) {\n    const pathRuleStack = this.getHumanReadableRuleStack();\n    const pathOccurrenceStack = (0, clone_1.default)(this.RULE_OCCURRENCE_STACK);\n    const grammarPath = {\n      ruleStack: pathRuleStack,\n      occurrenceStack: pathOccurrenceStack,\n      lastTok: tokType,\n      lastTokOccurrence: tokIdxInRule\n    };\n    return grammarPath;\n  }\n\n  getHumanReadableRuleStack() {\n    return (0, map_1.default)(this.RULE_STACK, currShortName => this.shortRuleNameToFullName(currShortName));\n  }\n\n}\n\nexports.Recoverable = Recoverable;\n\nfunction attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n  const key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n  let firstAfterRepInfo = this.firstAfterRepMap[key];\n\n  if (firstAfterRepInfo === undefined) {\n    const currRuleName = this.getCurrRuleFullName();\n    const ruleGrammar = this.getGAstProductions()[currRuleName];\n    const walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n    firstAfterRepInfo = walker.startWalking();\n    this.firstAfterRepMap[key] = firstAfterRepInfo;\n  }\n\n  let expectTokAfterLastMatch = firstAfterRepInfo.token;\n  let nextTokIdx = firstAfterRepInfo.occurrence;\n  const isEndOfRule = firstAfterRepInfo.isEndOfRule; // special edge case of a TOP most repetition after which the input should END.\n  // this will force an attempt for inRule recovery in that scenario.\n\n  if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === undefined) {\n    expectTokAfterLastMatch = tokens_public_1.EOF;\n    nextTokIdx = 1;\n  } // We don't have anything to re-sync to...\n  // this condition was extracted from `shouldInRepetitionRecoveryBeTried` to act as a type-guard\n\n\n  if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n    return;\n  }\n\n  if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n    // TODO: performance optimization: instead of passing the original args here, we modify\n    // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n    // to avoid searching the cache for it once more.\n    this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n  }\n}\n\nexports.attemptInRepetitionRecovery = attemptInRepetitionRecovery;","map":{"version":3,"sources":["../../../../../src/parse/parser/traits/recoverable.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.attemptInRepetitionRecovery = exports.Recoverable = exports.InRuleRecoveryException = exports.IN_RULE_RECOVERY_EXCEPTION = exports.EOF_FOLLOW_KEY = void 0;\nconst tokens_public_1 = require(\"../../../scan/tokens_public\");\nconst isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\nconst dropRight_1 = __importDefault(require(\"lodash/dropRight\"));\nconst flatten_1 = __importDefault(require(\"lodash/flatten\"));\nconst map_1 = __importDefault(require(\"lodash/map\"));\nconst find_1 = __importDefault(require(\"lodash/find\"));\nconst has_1 = __importDefault(require(\"lodash/has\"));\nconst includes_1 = __importDefault(require(\"lodash/includes\"));\nconst clone_1 = __importDefault(require(\"lodash/clone\"));\nconst exceptions_public_1 = require(\"../../exceptions_public\");\nconst constants_1 = require(\"../../constants\");\nconst parser_1 = require(\"../parser\");\nexports.EOF_FOLLOW_KEY = {};\nexports.IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\nclass InRuleRecoveryException extends Error {\n    constructor(message) {\n        super(message);\n        this.name = exports.IN_RULE_RECOVERY_EXCEPTION;\n    }\n}\nexports.InRuleRecoveryException = InRuleRecoveryException;\n/**\n * This trait is responsible for the error recovery and fault tolerant logic\n */\nclass Recoverable {\n    initRecoverable(config) {\n        this.firstAfterRepMap = {};\n        this.resyncFollows = {};\n        this.recoveryEnabled = (0, has_1.default)(config, \"recoveryEnabled\")\n            ? config.recoveryEnabled // assumes end user provides the correct config value/type\n            : parser_1.DEFAULT_PARSER_CONFIG.recoveryEnabled;\n        // performance optimization, NOOP will be inlined which\n        // effectively means that this optional feature does not exist\n        // when not used.\n        if (this.recoveryEnabled) {\n            this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n        }\n    }\n    getTokenToInsert(tokType) {\n        const tokToInsert = (0, tokens_public_1.createTokenInstance)(tokType, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n        tokToInsert.isInsertedInRecovery = true;\n        return tokToInsert;\n    }\n    canTokenTypeBeInsertedInRecovery(tokType) {\n        return true;\n    }\n    canTokenTypeBeDeletedInRecovery(tokType) {\n        return true;\n    }\n    tryInRepetitionRecovery(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n        // TODO: can the resyncTokenType be cached?\n        const reSyncTokType = this.findReSyncTokenType();\n        const savedLexerState = this.exportLexerState();\n        const resyncedTokens = [];\n        let passedResyncPoint = false;\n        const nextTokenWithoutResync = this.LA(1);\n        let currToken = this.LA(1);\n        const generateErrorMessage = () => {\n            const previousToken = this.LA(0);\n            // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n            // the error that would have been thrown\n            const msg = this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: expectedTokType,\n                actual: nextTokenWithoutResync,\n                previous: previousToken,\n                ruleName: this.getCurrRuleFullName()\n            });\n            const error = new exceptions_public_1.MismatchedTokenException(msg, nextTokenWithoutResync, this.LA(0));\n            // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n            error.resyncedTokens = (0, dropRight_1.default)(resyncedTokens);\n            this.SAVE_ERROR(error);\n        };\n        while (!passedResyncPoint) {\n            // re-synced to a point where we can safely exit the repetition/\n            if (this.tokenMatcher(currToken, expectedTokType)) {\n                generateErrorMessage();\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (lookAheadFunc.call(this)) {\n                // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n                generateErrorMessage();\n                // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n                grammarRule.apply(this, grammarRuleArgs);\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (this.tokenMatcher(currToken, reSyncTokType)) {\n                passedResyncPoint = true;\n            }\n            else {\n                currToken = this.SKIP_TOKEN();\n                this.addToResyncTokens(currToken, resyncedTokens);\n            }\n        }\n        // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n        // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n        // \"between rules\" resync recovery later in the flow.\n        this.importLexerState(savedLexerState);\n    }\n    shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck) {\n        // Edge case of arriving from a MANY repetition which is stuck\n        // Attempting recovery in this case could cause an infinite loop\n        if (notStuck === false) {\n            return false;\n        }\n        // no need to recover, next token is what we expect...\n        if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n            return false;\n        }\n        // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n        // and prefer some backtracking path that includes recovered errors.\n        if (this.isBackTracking()) {\n            return false;\n        }\n        // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n        // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n        //noinspection RedundantIfStatementJS\n        if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\n            return false;\n        }\n        return true;\n    }\n    // Error Recovery functionality\n    getFollowsForInRuleRecovery(tokType, tokIdxInRule) {\n        const grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n        const follows = this.getNextPossibleTokenTypes(grammarPath);\n        return follows;\n    }\n    tryInRuleRecovery(expectedTokType, follows) {\n        if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n            const tokToInsert = this.getTokenToInsert(expectedTokType);\n            return tokToInsert;\n        }\n        if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n            const nextTok = this.SKIP_TOKEN();\n            this.consumeToken();\n            return nextTok;\n        }\n        throw new InRuleRecoveryException(\"sad sad panda\");\n    }\n    canPerformInRuleRecovery(expectedToken, follows) {\n        return (this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||\n            this.canRecoverWithSingleTokenDeletion(expectedToken));\n    }\n    canRecoverWithSingleTokenInsertion(expectedTokType, follows) {\n        if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n            return false;\n        }\n        // must know the possible following tokens to perform single token insertion\n        if ((0, isEmpty_1.default)(follows)) {\n            return false;\n        }\n        const mismatchedTok = this.LA(1);\n        const isMisMatchedTokInFollows = (0, find_1.default)(follows, (possibleFollowsTokType) => {\n            return this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n        }) !== undefined;\n        return isMisMatchedTokInFollows;\n    }\n    canRecoverWithSingleTokenDeletion(expectedTokType) {\n        if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {\n            return false;\n        }\n        const isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n        return isNextTokenWhatIsExpected;\n    }\n    isInCurrentRuleReSyncSet(tokenTypeIdx) {\n        const followKey = this.getCurrFollowKey();\n        const currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n        return (0, includes_1.default)(currentRuleReSyncSet, tokenTypeIdx);\n    }\n    findReSyncTokenType() {\n        const allPossibleReSyncTokTypes = this.flattenFollowSet();\n        // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n        let nextToken = this.LA(1);\n        let k = 2;\n        while (true) {\n            const foundMatch = (0, find_1.default)(allPossibleReSyncTokTypes, (resyncTokType) => {\n                const canMatch = (0, tokens_public_1.tokenMatcher)(nextToken, resyncTokType);\n                return canMatch;\n            });\n            if (foundMatch !== undefined) {\n                return foundMatch;\n            }\n            nextToken = this.LA(k);\n            k++;\n        }\n    }\n    getCurrFollowKey() {\n        // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n        if (this.RULE_STACK.length === 1) {\n            return exports.EOF_FOLLOW_KEY;\n        }\n        const currRuleShortName = this.getLastExplicitRuleShortName();\n        const currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n        const prevRuleShortName = this.getPreviousExplicitRuleShortName();\n        return {\n            ruleName: this.shortRuleNameToFullName(currRuleShortName),\n            idxInCallingRule: currRuleIdx,\n            inRule: this.shortRuleNameToFullName(prevRuleShortName)\n        };\n    }\n    buildFullFollowKeyStack() {\n        const explicitRuleStack = this.RULE_STACK;\n        const explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return (0, map_1.default)(explicitRuleStack, (ruleName, idx) => {\n            if (idx === 0) {\n                return exports.EOF_FOLLOW_KEY;\n            }\n            return {\n                ruleName: this.shortRuleNameToFullName(ruleName),\n                idxInCallingRule: explicitOccurrenceStack[idx],\n                inRule: this.shortRuleNameToFullName(explicitRuleStack[idx - 1])\n            };\n        });\n    }\n    flattenFollowSet() {\n        const followStack = (0, map_1.default)(this.buildFullFollowKeyStack(), (currKey) => {\n            return this.getFollowSetFromFollowKey(currKey);\n        });\n        return (0, flatten_1.default)(followStack);\n    }\n    getFollowSetFromFollowKey(followKey) {\n        if (followKey === exports.EOF_FOLLOW_KEY) {\n            return [tokens_public_1.EOF];\n        }\n        const followName = followKey.ruleName + followKey.idxInCallingRule + constants_1.IN + followKey.inRule;\n        return this.resyncFollows[followName];\n    }\n    // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n    // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n    addToResyncTokens(token, resyncTokens) {\n        if (!this.tokenMatcher(token, tokens_public_1.EOF)) {\n            resyncTokens.push(token);\n        }\n        return resyncTokens;\n    }\n    reSyncTo(tokType) {\n        const resyncedTokens = [];\n        let nextTok = this.LA(1);\n        while (this.tokenMatcher(nextTok, tokType) === false) {\n            nextTok = this.SKIP_TOKEN();\n            this.addToResyncTokens(nextTok, resyncedTokens);\n        }\n        // the last token is not part of the error.\n        return (0, dropRight_1.default)(resyncedTokens);\n    }\n    attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n        // by default this is a NO-OP\n        // The actual implementation is with the function(not method) below\n    }\n    getCurrentGrammarPath(tokType, tokIdxInRule) {\n        const pathRuleStack = this.getHumanReadableRuleStack();\n        const pathOccurrenceStack = (0, clone_1.default)(this.RULE_OCCURRENCE_STACK);\n        const grammarPath = {\n            ruleStack: pathRuleStack,\n            occurrenceStack: pathOccurrenceStack,\n            lastTok: tokType,\n            lastTokOccurrence: tokIdxInRule\n        };\n        return grammarPath;\n    }\n    getHumanReadableRuleStack() {\n        return (0, map_1.default)(this.RULE_STACK, (currShortName) => this.shortRuleNameToFullName(currShortName));\n    }\n}\nexports.Recoverable = Recoverable;\nfunction attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n    const key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n    let firstAfterRepInfo = this.firstAfterRepMap[key];\n    if (firstAfterRepInfo === undefined) {\n        const currRuleName = this.getCurrRuleFullName();\n        const ruleGrammar = this.getGAstProductions()[currRuleName];\n        const walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n        firstAfterRepInfo = walker.startWalking();\n        this.firstAfterRepMap[key] = firstAfterRepInfo;\n    }\n    let expectTokAfterLastMatch = firstAfterRepInfo.token;\n    let nextTokIdx = firstAfterRepInfo.occurrence;\n    const isEndOfRule = firstAfterRepInfo.isEndOfRule;\n    // special edge case of a TOP most repetition after which the input should END.\n    // this will force an attempt for inRule recovery in that scenario.\n    if (this.RULE_STACK.length === 1 &&\n        isEndOfRule &&\n        expectTokAfterLastMatch === undefined) {\n        expectTokAfterLastMatch = tokens_public_1.EOF;\n        nextTokIdx = 1;\n    }\n    // We don't have anything to re-sync to...\n    // this condition was extracted from `shouldInRepetitionRecoveryBeTried` to act as a type-guard\n    if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n        return;\n    }\n    if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n        // TODO: performance optimization: instead of passing the original args here, we modify\n        // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n        // to avoid searching the cache for it once more.\n        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n    }\n}\nexports.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n//# sourceMappingURL=recoverable.js.map"]},"metadata":{},"sourceType":"script"}