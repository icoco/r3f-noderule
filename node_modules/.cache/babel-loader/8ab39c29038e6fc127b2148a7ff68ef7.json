{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.genDts = void 0;\n\nconst flatten_1 = __importDefault(require(\"lodash/flatten\"));\n\nconst isArray_1 = __importDefault(require(\"lodash/isArray\"));\n\nconst map_1 = __importDefault(require(\"lodash/map\"));\n\nconst reduce_1 = __importDefault(require(\"lodash/reduce\"));\n\nconst uniq_1 = __importDefault(require(\"lodash/uniq\"));\n\nconst upperFirst_1 = __importDefault(require(\"lodash/upperFirst\"));\n\nfunction genDts(model, options) {\n  let contentParts = [];\n  contentParts = contentParts.concat(`import type { CstNode, ICstVisitor, IToken } from \"chevrotain\";`);\n  contentParts = contentParts.concat((0, flatten_1.default)((0, map_1.default)(model, node => genCstNodeTypes(node))));\n\n  if (options.includeVisitorInterface) {\n    contentParts = contentParts.concat(genVisitor(options.visitorInterfaceName, model));\n  }\n\n  return contentParts.join(\"\\n\\n\") + \"\\n\";\n}\n\nexports.genDts = genDts;\n\nfunction genCstNodeTypes(node) {\n  const nodeCstInterface = genNodeInterface(node);\n  const nodeChildrenInterface = genNodeChildrenType(node);\n  return [nodeCstInterface, nodeChildrenInterface];\n}\n\nfunction genNodeInterface(node) {\n  const nodeInterfaceName = getNodeInterfaceName(node.name);\n  const childrenTypeName = getNodeChildrenTypeName(node.name);\n  return `export interface ${nodeInterfaceName} extends CstNode {\n  name: \"${node.name}\";\n  children: ${childrenTypeName};\n}`;\n}\n\nfunction genNodeChildrenType(node) {\n  const typeName = getNodeChildrenTypeName(node.name);\n  return `export type ${typeName} = {\n  ${(0, map_1.default)(node.properties, property => genChildProperty(property)).join(\"\\n  \")}\n};`;\n}\n\nfunction genChildProperty(prop) {\n  const typeName = buildTypeString(prop.type);\n  return `${prop.name}${prop.optional ? \"?\" : \"\"}: ${typeName}[];`;\n}\n\nfunction genVisitor(name, nodes) {\n  return `export interface ${name}<IN, OUT> extends ICstVisitor<IN, OUT> {\n  ${(0, map_1.default)(nodes, node => genVisitorFunction(node)).join(\"\\n  \")}\n}`;\n}\n\nfunction genVisitorFunction(node) {\n  const childrenTypeName = getNodeChildrenTypeName(node.name);\n  return `${node.name}(children: ${childrenTypeName}, param?: IN): OUT;`;\n}\n\nfunction buildTypeString(type) {\n  if ((0, isArray_1.default)(type)) {\n    const typeNames = (0, uniq_1.default)((0, map_1.default)(type, t => getTypeString(t)));\n    const typeString = (0, reduce_1.default)(typeNames, (sum, t) => sum + \" | \" + t);\n    return \"(\" + typeString + \")\";\n  } else {\n    return getTypeString(type);\n  }\n}\n\nfunction getTypeString(type) {\n  if (type.kind === \"token\") {\n    return \"IToken\";\n  }\n\n  return getNodeInterfaceName(type.name);\n}\n\nfunction getNodeInterfaceName(ruleName) {\n  return (0, upperFirst_1.default)(ruleName) + \"CstNode\";\n}\n\nfunction getNodeChildrenTypeName(ruleName) {\n  return (0, upperFirst_1.default)(ruleName) + \"CstChildren\";\n}","map":{"version":3,"sources":["../../src/generate.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,MAAA,SAAA,GAAA,eAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,CAAA;;AACA,MAAA,SAAA,GAAA,eAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,CAAA;;AACA,MAAA,KAAA,GAAA,eAAA,CAAA,OAAA,CAAA,YAAA,CAAA,CAAA;;AACA,MAAA,QAAA,GAAA,eAAA,CAAA,OAAA,CAAA,eAAA,CAAA,CAAA;;AACA,MAAA,MAAA,GAAA,eAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAA;;AACA,MAAA,YAAA,GAAA,eAAA,CAAA,OAAA,CAAA,mBAAA,CAAA,CAAA;;AAUA,SAAgB,MAAhB,CACE,KADF,EAEE,OAFF,EAEuC;AAErC,MAAI,YAAY,GAAa,EAA7B;AAEA,EAAA,YAAY,GAAG,YAAY,CAAC,MAAb,CACb,iEADa,CAAf;AAIA,EAAA,YAAY,GAAG,YAAY,CAAC,MAAb,CACb,CAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,CAAA,GAAA,KAAA,CAAA,OAAA,EAAI,KAAJ,EAAY,IAAD,IAAU,eAAe,CAAC,IAAD,CAApC,CAAR,CADa,CAAf;;AAIA,MAAI,OAAO,CAAC,uBAAZ,EAAqC;AACnC,IAAA,YAAY,GAAG,YAAY,CAAC,MAAb,CACb,UAAU,CAAC,OAAO,CAAC,oBAAT,EAA+B,KAA/B,CADG,CAAf;AAGD;;AAED,SAAO,YAAY,CAAC,IAAb,CAAkB,MAAlB,IAA4B,IAAnC;AACD;;AArBD,OAAA,CAAA,MAAA,GAAA,MAAA;;AAuBA,SAAS,eAAT,CAAyB,IAAzB,EAAoD;AAClD,QAAM,gBAAgB,GAAG,gBAAgB,CAAC,IAAD,CAAzC;AACA,QAAM,qBAAqB,GAAG,mBAAmB,CAAC,IAAD,CAAjD;AAEA,SAAO,CAAC,gBAAD,EAAmB,qBAAnB,CAAP;AACD;;AAED,SAAS,gBAAT,CAA0B,IAA1B,EAAqD;AACnD,QAAM,iBAAiB,GAAG,oBAAoB,CAAC,IAAI,CAAC,IAAN,CAA9C;AACA,QAAM,gBAAgB,GAAG,uBAAuB,CAAC,IAAI,CAAC,IAAN,CAAhD;AAEA,SAAO,oBAAoB,iBAAiB;WACnC,IAAI,CAAC,IAAI;cACN,gBAAgB;AAC5B,EAHA;AAID;;AAED,SAAS,mBAAT,CAA6B,IAA7B,EAAwD;AACtD,QAAM,QAAQ,GAAG,uBAAuB,CAAC,IAAI,CAAC,IAAN,CAAxC;AAEA,SAAO,eAAe,QAAQ;IAC5B,CAAA,GAAA,KAAA,CAAA,OAAA,EAAI,IAAI,CAAC,UAAT,EAAsB,QAAD,IAAc,gBAAgB,CAAC,QAAD,CAAnD,EAA+D,IAA/D,CAAoE,MAApE,CAA2E;AAC5E,GAFD;AAGD;;AAED,SAAS,gBAAT,CAA0B,IAA1B,EAAsD;AACpD,QAAM,QAAQ,GAAG,eAAe,CAAC,IAAI,CAAC,IAAN,CAAhC;AACA,SAAO,GAAG,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,QAAL,GAAgB,GAAhB,GAAsB,EAAE,KAAK,QAAQ,KAA3D;AACD;;AAED,SAAS,UAAT,CAAoB,IAApB,EAAkC,KAAlC,EAAgE;AAC9D,SAAO,oBAAoB,IAAI;IAC7B,CAAA,GAAA,KAAA,CAAA,OAAA,EAAI,KAAJ,EAAY,IAAD,IAAU,kBAAkB,CAAC,IAAD,CAAvC,EAA+C,IAA/C,CAAoD,MAApD,CAA2D;AAC7D,EAFA;AAGD;;AAED,SAAS,kBAAT,CAA4B,IAA5B,EAAuD;AACrD,QAAM,gBAAgB,GAAG,uBAAuB,CAAC,IAAI,CAAC,IAAN,CAAhD;AACA,SAAO,GAAG,IAAI,CAAC,IAAI,cAAc,gBAAgB,qBAAjD;AACD;;AAED,SAAS,eAAT,CAAyB,IAAzB,EAAgD;AAC9C,MAAI,CAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,IAAR,CAAJ,EAAmB;AACjB,UAAM,SAAS,GAAG,CAAA,GAAA,MAAA,CAAA,OAAA,EAAK,CAAA,GAAA,KAAA,CAAA,OAAA,EAAI,IAAJ,EAAW,CAAD,IAAO,aAAa,CAAC,CAAD,CAA9B,CAAL,CAAlB;AACA,UAAM,UAAU,GAAG,CAAA,GAAA,QAAA,CAAA,OAAA,EAAO,SAAP,EAAkB,CAAC,GAAD,EAAM,CAAN,KAAY,GAAG,GAAG,KAAN,GAAc,CAA5C,CAAnB;AACA,WAAO,MAAM,UAAN,GAAmB,GAA1B;AACD,GAJD,MAIO;AACL,WAAO,aAAa,CAAC,IAAD,CAApB;AACD;AACF;;AAED,SAAS,aAAT,CAAuB,IAAvB,EAA2D;AACzD,MAAI,IAAI,CAAC,IAAL,KAAc,OAAlB,EAA2B;AACzB,WAAO,QAAP;AACD;;AACD,SAAO,oBAAoB,CAAC,IAAI,CAAC,IAAN,CAA3B;AACD;;AAED,SAAS,oBAAT,CAA8B,QAA9B,EAA8C;AAC5C,SAAO,CAAA,GAAA,YAAA,CAAA,OAAA,EAAW,QAAX,IAAuB,SAA9B;AACD;;AAED,SAAS,uBAAT,CAAiC,QAAjC,EAAiD;AAC/C,SAAO,CAAA,GAAA,YAAA,CAAA,OAAA,EAAW,QAAX,IAAuB,aAA9B;AACD","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.genDts = void 0;\nconst flatten_1 = __importDefault(require(\"lodash/flatten\"));\nconst isArray_1 = __importDefault(require(\"lodash/isArray\"));\nconst map_1 = __importDefault(require(\"lodash/map\"));\nconst reduce_1 = __importDefault(require(\"lodash/reduce\"));\nconst uniq_1 = __importDefault(require(\"lodash/uniq\"));\nconst upperFirst_1 = __importDefault(require(\"lodash/upperFirst\"));\nfunction genDts(model, options) {\n    let contentParts = [];\n    contentParts = contentParts.concat(`import type { CstNode, ICstVisitor, IToken } from \"chevrotain\";`);\n    contentParts = contentParts.concat((0, flatten_1.default)((0, map_1.default)(model, (node) => genCstNodeTypes(node))));\n    if (options.includeVisitorInterface) {\n        contentParts = contentParts.concat(genVisitor(options.visitorInterfaceName, model));\n    }\n    return contentParts.join(\"\\n\\n\") + \"\\n\";\n}\nexports.genDts = genDts;\nfunction genCstNodeTypes(node) {\n    const nodeCstInterface = genNodeInterface(node);\n    const nodeChildrenInterface = genNodeChildrenType(node);\n    return [nodeCstInterface, nodeChildrenInterface];\n}\nfunction genNodeInterface(node) {\n    const nodeInterfaceName = getNodeInterfaceName(node.name);\n    const childrenTypeName = getNodeChildrenTypeName(node.name);\n    return `export interface ${nodeInterfaceName} extends CstNode {\n  name: \"${node.name}\";\n  children: ${childrenTypeName};\n}`;\n}\nfunction genNodeChildrenType(node) {\n    const typeName = getNodeChildrenTypeName(node.name);\n    return `export type ${typeName} = {\n  ${(0, map_1.default)(node.properties, (property) => genChildProperty(property)).join(\"\\n  \")}\n};`;\n}\nfunction genChildProperty(prop) {\n    const typeName = buildTypeString(prop.type);\n    return `${prop.name}${prop.optional ? \"?\" : \"\"}: ${typeName}[];`;\n}\nfunction genVisitor(name, nodes) {\n    return `export interface ${name}<IN, OUT> extends ICstVisitor<IN, OUT> {\n  ${(0, map_1.default)(nodes, (node) => genVisitorFunction(node)).join(\"\\n  \")}\n}`;\n}\nfunction genVisitorFunction(node) {\n    const childrenTypeName = getNodeChildrenTypeName(node.name);\n    return `${node.name}(children: ${childrenTypeName}, param?: IN): OUT;`;\n}\nfunction buildTypeString(type) {\n    if ((0, isArray_1.default)(type)) {\n        const typeNames = (0, uniq_1.default)((0, map_1.default)(type, (t) => getTypeString(t)));\n        const typeString = (0, reduce_1.default)(typeNames, (sum, t) => sum + \" | \" + t);\n        return \"(\" + typeString + \")\";\n    }\n    else {\n        return getTypeString(type);\n    }\n}\nfunction getTypeString(type) {\n    if (type.kind === \"token\") {\n        return \"IToken\";\n    }\n    return getNodeInterfaceName(type.name);\n}\nfunction getNodeInterfaceName(ruleName) {\n    return (0, upperFirst_1.default)(ruleName) + \"CstNode\";\n}\nfunction getNodeChildrenTypeName(ruleName) {\n    return (0, upperFirst_1.default)(ruleName) + \"CstChildren\";\n}\n//# sourceMappingURL=generate.js.map"]},"metadata":{},"sourceType":"script"}