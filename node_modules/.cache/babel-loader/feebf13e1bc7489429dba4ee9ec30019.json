{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ErrorHandler = void 0;\n\nconst exceptions_public_1 = require(\"../../exceptions_public\");\n\nconst has_1 = __importDefault(require(\"lodash/has\"));\n\nconst clone_1 = __importDefault(require(\"lodash/clone\"));\n\nconst lookahead_1 = require(\"../../grammar/lookahead\");\n\nconst parser_1 = require(\"../parser\");\n/**\n * Trait responsible for runtime parsing errors.\n */\n\n\nclass ErrorHandler {\n  initErrorHandler(config) {\n    this._errors = [];\n    this.errorMessageProvider = (0, has_1.default)(config, \"errorMessageProvider\") ? config.errorMessageProvider // assumes end user provides the correct config value/type\n    : parser_1.DEFAULT_PARSER_CONFIG.errorMessageProvider;\n  }\n\n  SAVE_ERROR(error) {\n    if ((0, exceptions_public_1.isRecognitionException)(error)) {\n      error.context = {\n        ruleStack: this.getHumanReadableRuleStack(),\n        ruleOccurrenceStack: (0, clone_1.default)(this.RULE_OCCURRENCE_STACK)\n      };\n\n      this._errors.push(error);\n\n      return error;\n    } else {\n      throw Error(\"Trying to save an Error which is not a RecognitionException\");\n    }\n  }\n\n  get errors() {\n    return (0, clone_1.default)(this._errors);\n  }\n\n  set errors(newErrors) {\n    this._errors = newErrors;\n  } // TODO: consider caching the error message computed information\n\n\n  raiseEarlyExitException(occurrence, prodType, userDefinedErrMsg) {\n    const ruleName = this.getCurrRuleFullName();\n    const ruleGrammar = this.getGAstProductions()[ruleName];\n    const lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOptionalProd)(occurrence, ruleGrammar, prodType, this.maxLookahead);\n    const insideProdPaths = lookAheadPathsPerAlternative[0];\n    const actualTokens = [];\n\n    for (let i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i));\n    }\n\n    const msg = this.errorMessageProvider.buildEarlyExitMessage({\n      expectedIterationPaths: insideProdPaths,\n      actual: actualTokens,\n      previous: this.LA(0),\n      customUserDescription: userDefinedErrMsg,\n      ruleName: ruleName\n    });\n    throw this.SAVE_ERROR(new exceptions_public_1.EarlyExitException(msg, this.LA(1), this.LA(0)));\n  } // TODO: consider caching the error message computed information\n\n\n  raiseNoAltException(occurrence, errMsgTypes) {\n    const ruleName = this.getCurrRuleFullName();\n    const ruleGrammar = this.getGAstProductions()[ruleName]; // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n\n    const lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOr)(occurrence, ruleGrammar, this.maxLookahead);\n    const actualTokens = [];\n\n    for (let i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i));\n    }\n\n    const previousToken = this.LA(0);\n    const errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n      expectedPathsPerAlt: lookAheadPathsPerAlternative,\n      actual: actualTokens,\n      previous: previousToken,\n      customUserDescription: errMsgTypes,\n      ruleName: this.getCurrRuleFullName()\n    });\n    throw this.SAVE_ERROR(new exceptions_public_1.NoViableAltException(errMsg, this.LA(1), previousToken));\n  }\n\n}\n\nexports.ErrorHandler = ErrorHandler;","map":{"version":3,"sources":["../../../../../src/parse/parser/traits/error_handler.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ErrorHandler = void 0;\nconst exceptions_public_1 = require(\"../../exceptions_public\");\nconst has_1 = __importDefault(require(\"lodash/has\"));\nconst clone_1 = __importDefault(require(\"lodash/clone\"));\nconst lookahead_1 = require(\"../../grammar/lookahead\");\nconst parser_1 = require(\"../parser\");\n/**\n * Trait responsible for runtime parsing errors.\n */\nclass ErrorHandler {\n    initErrorHandler(config) {\n        this._errors = [];\n        this.errorMessageProvider = (0, has_1.default)(config, \"errorMessageProvider\")\n            ? config.errorMessageProvider // assumes end user provides the correct config value/type\n            : parser_1.DEFAULT_PARSER_CONFIG.errorMessageProvider;\n    }\n    SAVE_ERROR(error) {\n        if ((0, exceptions_public_1.isRecognitionException)(error)) {\n            error.context = {\n                ruleStack: this.getHumanReadableRuleStack(),\n                ruleOccurrenceStack: (0, clone_1.default)(this.RULE_OCCURRENCE_STACK)\n            };\n            this._errors.push(error);\n            return error;\n        }\n        else {\n            throw Error(\"Trying to save an Error which is not a RecognitionException\");\n        }\n    }\n    get errors() {\n        return (0, clone_1.default)(this._errors);\n    }\n    set errors(newErrors) {\n        this._errors = newErrors;\n    }\n    // TODO: consider caching the error message computed information\n    raiseEarlyExitException(occurrence, prodType, userDefinedErrMsg) {\n        const ruleName = this.getCurrRuleFullName();\n        const ruleGrammar = this.getGAstProductions()[ruleName];\n        const lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOptionalProd)(occurrence, ruleGrammar, prodType, this.maxLookahead);\n        const insideProdPaths = lookAheadPathsPerAlternative[0];\n        const actualTokens = [];\n        for (let i = 1; i <= this.maxLookahead; i++) {\n            actualTokens.push(this.LA(i));\n        }\n        const msg = this.errorMessageProvider.buildEarlyExitMessage({\n            expectedIterationPaths: insideProdPaths,\n            actual: actualTokens,\n            previous: this.LA(0),\n            customUserDescription: userDefinedErrMsg,\n            ruleName: ruleName\n        });\n        throw this.SAVE_ERROR(new exceptions_public_1.EarlyExitException(msg, this.LA(1), this.LA(0)));\n    }\n    // TODO: consider caching the error message computed information\n    raiseNoAltException(occurrence, errMsgTypes) {\n        const ruleName = this.getCurrRuleFullName();\n        const ruleGrammar = this.getGAstProductions()[ruleName];\n        // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n        const lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOr)(occurrence, ruleGrammar, this.maxLookahead);\n        const actualTokens = [];\n        for (let i = 1; i <= this.maxLookahead; i++) {\n            actualTokens.push(this.LA(i));\n        }\n        const previousToken = this.LA(0);\n        const errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n            expectedPathsPerAlt: lookAheadPathsPerAlternative,\n            actual: actualTokens,\n            previous: previousToken,\n            customUserDescription: errMsgTypes,\n            ruleName: this.getCurrRuleFullName()\n        });\n        throw this.SAVE_ERROR(new exceptions_public_1.NoViableAltException(errMsg, this.LA(1), previousToken));\n    }\n}\nexports.ErrorHandler = ErrorHandler;\n//# sourceMappingURL=error_handler.js.map"]},"metadata":{},"sourceType":"script"}