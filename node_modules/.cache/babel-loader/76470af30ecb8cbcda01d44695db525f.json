{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RecognizerEngine = void 0;\n\nconst isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\n\nconst isArray_1 = __importDefault(require(\"lodash/isArray\"));\n\nconst flatten_1 = __importDefault(require(\"lodash/flatten\"));\n\nconst every_1 = __importDefault(require(\"lodash/every\"));\n\nconst uniq_1 = __importDefault(require(\"lodash/uniq\"));\n\nconst isObject_1 = __importDefault(require(\"lodash/isObject\"));\n\nconst has_1 = __importDefault(require(\"lodash/has\"));\n\nconst values_1 = __importDefault(require(\"lodash/values\"));\n\nconst reduce_1 = __importDefault(require(\"lodash/reduce\"));\n\nconst clone_1 = __importDefault(require(\"lodash/clone\"));\n\nconst keys_1 = require(\"../../grammar/keys\");\n\nconst exceptions_public_1 = require(\"../../exceptions_public\");\n\nconst lookahead_1 = require(\"../../grammar/lookahead\");\n\nconst interpreter_1 = require(\"../../grammar/interpreter\");\n\nconst parser_1 = require(\"../parser\");\n\nconst recoverable_1 = require(\"./recoverable\");\n\nconst tokens_public_1 = require(\"../../../scan/tokens_public\");\n\nconst tokens_1 = require(\"../../../scan/tokens\");\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\n\n\nclass RecognizerEngine {\n  initRecognizerEngine(tokenVocabulary, config) {\n    this.className = this.constructor.name; // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n\n    this.shortRuleNameToFull = {};\n    this.fullRuleNameToShort = {};\n    this.ruleShortNameIdx = 256;\n    this.tokenMatcher = tokens_1.tokenStructuredMatcherNoCategories;\n    this.subruleIdx = 0;\n    this.definedRulesNames = [];\n    this.tokensMap = {};\n    this.isBackTrackingStack = [];\n    this.RULE_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n    this.gastProductionsCache = {};\n\n    if ((0, has_1.default)(config, \"serializedGrammar\")) {\n      throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" + \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" + \"\\tFor Further details.\");\n    }\n\n    if ((0, isArray_1.default)(tokenVocabulary)) {\n      // This only checks for Token vocabularies provided as arrays.\n      // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n      // rather than all edge cases of empty Token vocabularies.\n      if ((0, isEmpty_1.default)(tokenVocabulary)) {\n        throw Error(\"A Token Vocabulary cannot be empty.\\n\" + \"\\tNote that the first argument for the parser constructor\\n\" + \"\\tis no longer a Token vector (since v4.0).\");\n      }\n\n      if (typeof tokenVocabulary[0].startOffset === \"number\") {\n        throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\" + \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" + \"\\tFor Further details.\");\n      }\n    }\n\n    if ((0, isArray_1.default)(tokenVocabulary)) {\n      this.tokensMap = (0, reduce_1.default)(tokenVocabulary, (acc, tokType) => {\n        acc[tokType.name] = tokType;\n        return acc;\n      }, {});\n    } else if ((0, has_1.default)(tokenVocabulary, \"modes\") && (0, every_1.default)((0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes)), tokens_1.isTokenType)) {\n      const allTokenTypes = (0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes));\n      const uniqueTokens = (0, uniq_1.default)(allTokenTypes);\n      this.tokensMap = (0, reduce_1.default)(uniqueTokens, (acc, tokType) => {\n        acc[tokType.name] = tokType;\n        return acc;\n      }, {});\n    } else if ((0, isObject_1.default)(tokenVocabulary)) {\n      this.tokensMap = (0, clone_1.default)(tokenVocabulary);\n    } else {\n      throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors,\" + \" A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n    } // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n    // parsed with a clear error message (\"expecting EOF but found ...\")\n\n\n    this.tokensMap[\"EOF\"] = tokens_public_1.EOF;\n    const allTokenTypes = (0, has_1.default)(tokenVocabulary, \"modes\") ? (0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes)) : (0, values_1.default)(tokenVocabulary);\n    const noTokenCategoriesUsed = (0, every_1.default)(allTokenTypes, tokenConstructor => (0, isEmpty_1.default)(tokenConstructor.categoryMatches));\n    this.tokenMatcher = noTokenCategoriesUsed ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher; // Because ES2015+ syntax should be supported for creating Token classes\n    // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n    // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n\n    (0, tokens_1.augmentTokenTypes)((0, values_1.default)(this.tokensMap));\n  }\n\n  defineRule(ruleName, impl, config) {\n    if (this.selfAnalysisDone) {\n      throw Error(`Grammar rule <${ruleName}> may not be defined after the 'performSelfAnalysis' method has been called'\\n` + `Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`);\n    }\n\n    const resyncEnabled = (0, has_1.default)(config, \"resyncEnabled\") ? config.resyncEnabled // assumes end user provides the correct config value/type\n    : parser_1.DEFAULT_RULE_CONFIG.resyncEnabled;\n    const recoveryValueFunc = (0, has_1.default)(config, \"recoveryValueFunc\") ? config.recoveryValueFunc // assumes end user provides the correct config value/type\n    : parser_1.DEFAULT_RULE_CONFIG.recoveryValueFunc; // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n    // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n\n    const shortName = this.ruleShortNameIdx << keys_1.BITS_FOR_METHOD_TYPE + keys_1.BITS_FOR_OCCURRENCE_IDX;\n    this.ruleShortNameIdx++;\n    this.shortRuleNameToFull[shortName] = ruleName;\n    this.fullRuleNameToShort[ruleName] = shortName;\n    let invokeRuleWithTry; // Micro optimization, only check the condition **once** on rule definition\n    // instead of **every single** rule invocation.\n\n    if (this.outputCst === true) {\n      invokeRuleWithTry = function invokeRuleWithTry(...args) {\n        try {\n          this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n          impl.apply(this, args);\n          const cst = this.CST_STACK[this.CST_STACK.length - 1];\n          this.cstPostRule(cst);\n          return cst;\n        } catch (e) {\n          return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n        } finally {\n          this.ruleFinallyStateUpdate();\n        }\n      };\n    } else {\n      invokeRuleWithTry = function invokeRuleWithTryCst(...args) {\n        try {\n          this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n          return impl.apply(this, args);\n        } catch (e) {\n          return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n        } finally {\n          this.ruleFinallyStateUpdate();\n        }\n      };\n    }\n\n    const wrappedGrammarRule = Object.assign(invokeRuleWithTry, {\n      ruleName,\n      originalGrammarAction: impl\n    });\n    return wrappedGrammarRule;\n  }\n\n  invokeRuleCatch(e, resyncEnabledConfig, recoveryValueFunc) {\n    const isFirstInvokedRule = this.RULE_STACK.length === 1; // note the reSync is always enabled for the first rule invocation, because we must always be able to\n    // reSync with EOF and just output some INVALID ParseTree\n    // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n    // path is really the most valid one\n\n    const reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n\n    if ((0, exceptions_public_1.isRecognitionException)(e)) {\n      const recogError = e;\n\n      if (reSyncEnabled) {\n        const reSyncTokType = this.findReSyncTokenType();\n\n        if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n          recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n\n          if (this.outputCst) {\n            const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            return partialCstResult;\n          } else {\n            return recoveryValueFunc();\n          }\n        } else {\n          if (this.outputCst) {\n            const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            recogError.partialCstResult = partialCstResult;\n          } // to be handled Further up the call stack\n\n\n          throw recogError;\n        }\n      } else if (isFirstInvokedRule) {\n        // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n        this.moveToTerminatedState(); // the parser should never throw one of its own errors outside its flow.\n        // even if error recovery is disabled\n\n        return recoveryValueFunc();\n      } else {\n        // to be recovered Further up the call stack\n        throw recogError;\n      }\n    } else {\n      // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n      throw e;\n    }\n  } // Implementation of parsing DSL\n\n\n  optionInternal(actionORMethodDef, occurrence) {\n    const key = this.getKeyForAutomaticLookahead(keys_1.OPTION_IDX, occurrence);\n    return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n  }\n\n  optionInternalLogic(actionORMethodDef, occurrence, key) {\n    let lookAheadFunc = this.getLaFuncFromCache(key);\n    let action;\n\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF;\n      const predicate = actionORMethodDef.GATE; // predicate present\n\n      if (predicate !== undefined) {\n        const orgLookaheadFunction = lookAheadFunc;\n\n        lookAheadFunc = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n\n    if (lookAheadFunc.call(this) === true) {\n      return action.call(this);\n    }\n\n    return undefined;\n  }\n\n  atLeastOneInternal(prodOccurrence, actionORMethodDef) {\n    const laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_IDX, prodOccurrence);\n    return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n  }\n\n  atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key) {\n    let lookAheadFunc = this.getLaFuncFromCache(key);\n    let action;\n\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF;\n      const predicate = actionORMethodDef.GATE; // predicate present\n\n      if (predicate !== undefined) {\n        const orgLookaheadFunction = lookAheadFunc;\n\n        lookAheadFunc = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n\n    if (lookAheadFunc.call(this) === true) {\n      let notStuck = this.doSingleRepetition(action);\n\n      while (lookAheadFunc.call(this) === true && notStuck === true) {\n        notStuck = this.doSingleRepetition(action);\n      }\n    } else {\n      throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n    } // note that while it may seem that this can cause an error because by using a recursive call to\n    // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n    // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n\n\n    this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, keys_1.AT_LEAST_ONE_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneWalker);\n  }\n\n  atLeastOneSepFirstInternal(prodOccurrence, options) {\n    const laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n    this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n  }\n\n  atLeastOneSepFirstInternalLogic(prodOccurrence, options, key) {\n    const action = options.DEF;\n    const separator = options.SEP;\n    const firstIterationLookaheadFunc = this.getLaFuncFromCache(key); // 1st iteration\n\n    if (firstIterationLookaheadFunc.call(this) === true) {\n      ;\n      action.call(this); //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n      //  because it is only needed in error recovery scenarios.\n\n      const separatorLookAheadFunc = () => {\n        return this.tokenMatcher(this.LA(1), separator);\n      }; // 2nd..nth iterations\n\n\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator);\n        action.call(this);\n      } // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n\n\n      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, interpreter_1.NextTerminalAfterAtLeastOneSepWalker], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneSepWalker);\n    } else {\n      throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n    }\n  }\n\n  manyInternal(prodOccurrence, actionORMethodDef) {\n    const laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_IDX, prodOccurrence);\n    return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n  }\n\n  manyInternalLogic(prodOccurrence, actionORMethodDef, key) {\n    let lookaheadFunction = this.getLaFuncFromCache(key);\n    let action;\n\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF;\n      const predicate = actionORMethodDef.GATE; // predicate present\n\n      if (predicate !== undefined) {\n        const orgLookaheadFunction = lookaheadFunction;\n\n        lookaheadFunction = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n\n    let notStuck = true;\n\n    while (lookaheadFunction.call(this) === true && notStuck === true) {\n      notStuck = this.doSingleRepetition(action);\n    } // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n\n\n    this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, keys_1.MANY_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManyWalker, // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n    // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n    // An infinite loop cannot occur as:\n    // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n    // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n    notStuck);\n  }\n\n  manySepFirstInternal(prodOccurrence, options) {\n    const laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_SEP_IDX, prodOccurrence);\n    this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n  }\n\n  manySepFirstInternalLogic(prodOccurrence, options, key) {\n    const action = options.DEF;\n    const separator = options.SEP;\n    const firstIterationLaFunc = this.getLaFuncFromCache(key); // 1st iteration\n\n    if (firstIterationLaFunc.call(this) === true) {\n      action.call(this);\n\n      const separatorLookAheadFunc = () => {\n        return this.tokenMatcher(this.LA(1), separator);\n      }; // 2nd..nth iterations\n\n\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator); // No need for checking infinite loop here due to consuming the separator.\n\n        action.call(this);\n      } // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n\n\n      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, interpreter_1.NextTerminalAfterManySepWalker], separatorLookAheadFunc, keys_1.MANY_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManySepWalker);\n    }\n  }\n\n  repetitionSepSecondInternal(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n    while (separatorLookAheadFunc()) {\n      // note that this CONSUME will never enter recovery because\n      // the separatorLookAheadFunc checks that the separator really does exist.\n      this.CONSUME(separator);\n      action.call(this);\n    } // we can only arrive to this function after an error\n    // has occurred (hence the name 'second') so the following\n    // IF will always be entered, its possible to remove it...\n    // however it is kept to avoid confusion and be consistent.\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n\n    /* istanbul ignore else */\n\n\n    this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n  }\n\n  doSingleRepetition(action) {\n    const beforeIteration = this.getLexerPosition();\n    action.call(this);\n    const afterIteration = this.getLexerPosition(); // This boolean will indicate if this repetition progressed\n    // or if we are \"stuck\" (potential infinite loop in the repetition).\n\n    return afterIteration > beforeIteration;\n  }\n\n  orInternal(altsOrOpts, occurrence) {\n    const laKey = this.getKeyForAutomaticLookahead(keys_1.OR_IDX, occurrence);\n    const alts = (0, isArray_1.default)(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n    const laFunc = this.getLaFuncFromCache(laKey);\n    const altIdxToTake = laFunc.call(this, alts);\n\n    if (altIdxToTake !== undefined) {\n      const chosenAlternative = alts[altIdxToTake];\n      return chosenAlternative.ALT.call(this);\n    }\n\n    this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n  }\n\n  ruleFinallyStateUpdate() {\n    this.RULE_STACK.pop();\n    this.RULE_OCCURRENCE_STACK.pop(); // NOOP when cst is disabled\n\n    this.cstFinallyStateUpdate();\n\n    if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n      const firstRedundantTok = this.LA(1);\n      const errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n        firstRedundant: firstRedundantTok,\n        ruleName: this.getCurrRuleFullName()\n      });\n      this.SAVE_ERROR(new exceptions_public_1.NotAllInputParsedException(errMsg, firstRedundantTok));\n    }\n  }\n\n  subruleInternal(ruleToCall, idx, options) {\n    let ruleResult;\n\n    try {\n      const args = options !== undefined ? options.ARGS : undefined;\n      this.subruleIdx = idx;\n      ruleResult = ruleToCall.apply(this, args);\n      this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleToCall.ruleName);\n      return ruleResult;\n    } catch (e) {\n      throw this.subruleInternalError(e, options, ruleToCall.ruleName);\n    }\n  }\n\n  subruleInternalError(e, options, ruleName) {\n    if ((0, exceptions_public_1.isRecognitionException)(e) && e.partialCstResult !== undefined) {\n      this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleName);\n      delete e.partialCstResult;\n    }\n\n    throw e;\n  }\n\n  consumeInternal(tokType, idx, options) {\n    let consumedToken;\n\n    try {\n      const nextToken = this.LA(1);\n\n      if (this.tokenMatcher(nextToken, tokType) === true) {\n        this.consumeToken();\n        consumedToken = nextToken;\n      } else {\n        this.consumeInternalError(tokType, nextToken, options);\n      }\n    } catch (eFromConsumption) {\n      consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n    }\n\n    this.cstPostTerminal(options !== undefined && options.LABEL !== undefined ? options.LABEL : tokType.name, consumedToken);\n    return consumedToken;\n  }\n\n  consumeInternalError(tokType, nextToken, options) {\n    let msg;\n    const previousToken = this.LA(0);\n\n    if (options !== undefined && options.ERR_MSG) {\n      msg = options.ERR_MSG;\n    } else {\n      msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: tokType,\n        actual: nextToken,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName()\n      });\n    }\n\n    throw this.SAVE_ERROR(new exceptions_public_1.MismatchedTokenException(msg, nextToken, previousToken));\n  }\n\n  consumeInternalRecovery(tokType, idx, eFromConsumption) {\n    // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n    // but the original syntax could have been parsed successfully without any backtracking + recovery\n    if (this.recoveryEnabled && // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n    eFromConsumption.name === \"MismatchedTokenException\" && !this.isBackTracking()) {\n      const follows = this.getFollowsForInRuleRecovery(tokType, idx);\n\n      try {\n        return this.tryInRuleRecovery(tokType, follows);\n      } catch (eFromInRuleRecovery) {\n        if (eFromInRuleRecovery.name === recoverable_1.IN_RULE_RECOVERY_EXCEPTION) {\n          // failed in RuleRecovery.\n          // throw the original error in order to trigger reSync error recovery\n          throw eFromConsumption;\n        } else {\n          throw eFromInRuleRecovery;\n        }\n      }\n    } else {\n      throw eFromConsumption;\n    }\n  }\n\n  saveRecogState() {\n    // errors is a getter which will clone the errors array\n    const savedErrors = this.errors;\n    const savedRuleStack = (0, clone_1.default)(this.RULE_STACK);\n    return {\n      errors: savedErrors,\n      lexerState: this.exportLexerState(),\n      RULE_STACK: savedRuleStack,\n      CST_STACK: this.CST_STACK\n    };\n  }\n\n  reloadRecogState(newState) {\n    this.errors = newState.errors;\n    this.importLexerState(newState.lexerState);\n    this.RULE_STACK = newState.RULE_STACK;\n  }\n\n  ruleInvocationStateUpdate(shortName, fullName, idxInCallingRule) {\n    this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n    this.RULE_STACK.push(shortName); // NOOP when cst is disabled\n\n    this.cstInvocationStateUpdate(fullName);\n  }\n\n  isBackTracking() {\n    return this.isBackTrackingStack.length !== 0;\n  }\n\n  getCurrRuleFullName() {\n    const shortName = this.getLastExplicitRuleShortName();\n    return this.shortRuleNameToFull[shortName];\n  }\n\n  shortRuleNameToFullName(shortName) {\n    return this.shortRuleNameToFull[shortName];\n  }\n\n  isAtEndOfInput() {\n    return this.tokenMatcher(this.LA(1), tokens_public_1.EOF);\n  }\n\n  reset() {\n    this.resetLexerState();\n    this.subruleIdx = 0;\n    this.isBackTrackingStack = [];\n    this.errors = [];\n    this.RULE_STACK = []; // TODO: extract a specific reset for TreeBuilder trait\n\n    this.CST_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n  }\n\n}\n\nexports.RecognizerEngine = RecognizerEngine;","map":{"version":3,"sources":["../../../../../src/parse/parser/traits/recognizer_engine.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RecognizerEngine = void 0;\nconst isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\nconst isArray_1 = __importDefault(require(\"lodash/isArray\"));\nconst flatten_1 = __importDefault(require(\"lodash/flatten\"));\nconst every_1 = __importDefault(require(\"lodash/every\"));\nconst uniq_1 = __importDefault(require(\"lodash/uniq\"));\nconst isObject_1 = __importDefault(require(\"lodash/isObject\"));\nconst has_1 = __importDefault(require(\"lodash/has\"));\nconst values_1 = __importDefault(require(\"lodash/values\"));\nconst reduce_1 = __importDefault(require(\"lodash/reduce\"));\nconst clone_1 = __importDefault(require(\"lodash/clone\"));\nconst keys_1 = require(\"../../grammar/keys\");\nconst exceptions_public_1 = require(\"../../exceptions_public\");\nconst lookahead_1 = require(\"../../grammar/lookahead\");\nconst interpreter_1 = require(\"../../grammar/interpreter\");\nconst parser_1 = require(\"../parser\");\nconst recoverable_1 = require(\"./recoverable\");\nconst tokens_public_1 = require(\"../../../scan/tokens_public\");\nconst tokens_1 = require(\"../../../scan/tokens\");\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\nclass RecognizerEngine {\n    initRecognizerEngine(tokenVocabulary, config) {\n        this.className = this.constructor.name;\n        // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n        this.shortRuleNameToFull = {};\n        this.fullRuleNameToShort = {};\n        this.ruleShortNameIdx = 256;\n        this.tokenMatcher = tokens_1.tokenStructuredMatcherNoCategories;\n        this.subruleIdx = 0;\n        this.definedRulesNames = [];\n        this.tokensMap = {};\n        this.isBackTrackingStack = [];\n        this.RULE_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n        this.gastProductionsCache = {};\n        if ((0, has_1.default)(config, \"serializedGrammar\")) {\n            throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" +\n                \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" +\n                \"\\tFor Further details.\");\n        }\n        if ((0, isArray_1.default)(tokenVocabulary)) {\n            // This only checks for Token vocabularies provided as arrays.\n            // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n            // rather than all edge cases of empty Token vocabularies.\n            if ((0, isEmpty_1.default)(tokenVocabulary)) {\n                throw Error(\"A Token Vocabulary cannot be empty.\\n\" +\n                    \"\\tNote that the first argument for the parser constructor\\n\" +\n                    \"\\tis no longer a Token vector (since v4.0).\");\n            }\n            if (typeof tokenVocabulary[0].startOffset === \"number\") {\n                throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\" +\n                    \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" +\n                    \"\\tFor Further details.\");\n            }\n        }\n        if ((0, isArray_1.default)(tokenVocabulary)) {\n            this.tokensMap = (0, reduce_1.default)(tokenVocabulary, (acc, tokType) => {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if ((0, has_1.default)(tokenVocabulary, \"modes\") &&\n            (0, every_1.default)((0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes)), tokens_1.isTokenType)) {\n            const allTokenTypes = (0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes));\n            const uniqueTokens = (0, uniq_1.default)(allTokenTypes);\n            this.tokensMap = (0, reduce_1.default)(uniqueTokens, (acc, tokType) => {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if ((0, isObject_1.default)(tokenVocabulary)) {\n            this.tokensMap = (0, clone_1.default)(tokenVocabulary);\n        }\n        else {\n            throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors,\" +\n                \" A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n        }\n        // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n        // parsed with a clear error message (\"expecting EOF but found ...\")\n        this.tokensMap[\"EOF\"] = tokens_public_1.EOF;\n        const allTokenTypes = (0, has_1.default)(tokenVocabulary, \"modes\")\n            ? (0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes))\n            : (0, values_1.default)(tokenVocabulary);\n        const noTokenCategoriesUsed = (0, every_1.default)(allTokenTypes, (tokenConstructor) => (0, isEmpty_1.default)(tokenConstructor.categoryMatches));\n        this.tokenMatcher = noTokenCategoriesUsed\n            ? tokens_1.tokenStructuredMatcherNoCategories\n            : tokens_1.tokenStructuredMatcher;\n        // Because ES2015+ syntax should be supported for creating Token classes\n        // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n        // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n        (0, tokens_1.augmentTokenTypes)((0, values_1.default)(this.tokensMap));\n    }\n    defineRule(ruleName, impl, config) {\n        if (this.selfAnalysisDone) {\n            throw Error(`Grammar rule <${ruleName}> may not be defined after the 'performSelfAnalysis' method has been called'\\n` +\n                `Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`);\n        }\n        const resyncEnabled = (0, has_1.default)(config, \"resyncEnabled\")\n            ? config.resyncEnabled // assumes end user provides the correct config value/type\n            : parser_1.DEFAULT_RULE_CONFIG.resyncEnabled;\n        const recoveryValueFunc = (0, has_1.default)(config, \"recoveryValueFunc\")\n            ? config.recoveryValueFunc // assumes end user provides the correct config value/type\n            : parser_1.DEFAULT_RULE_CONFIG.recoveryValueFunc;\n        // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n        // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n        const shortName = this.ruleShortNameIdx << (keys_1.BITS_FOR_METHOD_TYPE + keys_1.BITS_FOR_OCCURRENCE_IDX);\n        this.ruleShortNameIdx++;\n        this.shortRuleNameToFull[shortName] = ruleName;\n        this.fullRuleNameToShort[ruleName] = shortName;\n        let invokeRuleWithTry;\n        // Micro optimization, only check the condition **once** on rule definition\n        // instead of **every single** rule invocation.\n        if (this.outputCst === true) {\n            invokeRuleWithTry = function invokeRuleWithTry(...args) {\n                try {\n                    this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n                    impl.apply(this, args);\n                    const cst = this.CST_STACK[this.CST_STACK.length - 1];\n                    this.cstPostRule(cst);\n                    return cst;\n                }\n                catch (e) {\n                    return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n                }\n                finally {\n                    this.ruleFinallyStateUpdate();\n                }\n            };\n        }\n        else {\n            invokeRuleWithTry = function invokeRuleWithTryCst(...args) {\n                try {\n                    this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n                    return impl.apply(this, args);\n                }\n                catch (e) {\n                    return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n                }\n                finally {\n                    this.ruleFinallyStateUpdate();\n                }\n            };\n        }\n        const wrappedGrammarRule = Object.assign(invokeRuleWithTry, { ruleName, originalGrammarAction: impl });\n        return wrappedGrammarRule;\n    }\n    invokeRuleCatch(e, resyncEnabledConfig, recoveryValueFunc) {\n        const isFirstInvokedRule = this.RULE_STACK.length === 1;\n        // note the reSync is always enabled for the first rule invocation, because we must always be able to\n        // reSync with EOF and just output some INVALID ParseTree\n        // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n        // path is really the most valid one\n        const reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n        if ((0, exceptions_public_1.isRecognitionException)(e)) {\n            const recogError = e;\n            if (reSyncEnabled) {\n                const reSyncTokType = this.findReSyncTokenType();\n                if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n                    recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n                    if (this.outputCst) {\n                        const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        return partialCstResult;\n                    }\n                    else {\n                        return recoveryValueFunc();\n                    }\n                }\n                else {\n                    if (this.outputCst) {\n                        const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        recogError.partialCstResult = partialCstResult;\n                    }\n                    // to be handled Further up the call stack\n                    throw recogError;\n                }\n            }\n            else if (isFirstInvokedRule) {\n                // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n                this.moveToTerminatedState();\n                // the parser should never throw one of its own errors outside its flow.\n                // even if error recovery is disabled\n                return recoveryValueFunc();\n            }\n            else {\n                // to be recovered Further up the call stack\n                throw recogError;\n            }\n        }\n        else {\n            // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n            throw e;\n        }\n    }\n    // Implementation of parsing DSL\n    optionInternal(actionORMethodDef, occurrence) {\n        const key = this.getKeyForAutomaticLookahead(keys_1.OPTION_IDX, occurrence);\n        return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n    }\n    optionInternalLogic(actionORMethodDef, occurrence, key) {\n        let lookAheadFunc = this.getLaFuncFromCache(key);\n        let action;\n        if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            const predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                const orgLookaheadFunction = lookAheadFunc;\n                lookAheadFunc = () => {\n                    return predicate.call(this) && orgLookaheadFunction.call(this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            return action.call(this);\n        }\n        return undefined;\n    }\n    atLeastOneInternal(prodOccurrence, actionORMethodDef) {\n        const laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_IDX, prodOccurrence);\n        return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    }\n    atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key) {\n        let lookAheadFunc = this.getLaFuncFromCache(key);\n        let action;\n        if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            const predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                const orgLookaheadFunction = lookAheadFunc;\n                lookAheadFunc = () => {\n                    return predicate.call(this) && orgLookaheadFunction.call(this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            let notStuck = this.doSingleRepetition(action);\n            while (lookAheadFunc.call(this) === true &&\n                notStuck === true) {\n                notStuck = this.doSingleRepetition(action);\n            }\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n        }\n        // note that while it may seem that this can cause an error because by using a recursive call to\n        // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n        // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, keys_1.AT_LEAST_ONE_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneWalker);\n    }\n    atLeastOneSepFirstInternal(prodOccurrence, options) {\n        const laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n        this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n    }\n    atLeastOneSepFirstInternalLogic(prodOccurrence, options, key) {\n        const action = options.DEF;\n        const separator = options.SEP;\n        const firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLookaheadFunc.call(this) === true) {\n            ;\n            action.call(this);\n            //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n            //  because it is only needed in error recovery scenarios.\n            const separatorLookAheadFunc = () => {\n                return this.tokenMatcher(this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                action.call(this);\n            }\n            // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                interpreter_1.NextTerminalAfterAtLeastOneSepWalker\n            ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneSepWalker);\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n        }\n    }\n    manyInternal(prodOccurrence, actionORMethodDef) {\n        const laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_IDX, prodOccurrence);\n        return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    }\n    manyInternalLogic(prodOccurrence, actionORMethodDef, key) {\n        let lookaheadFunction = this.getLaFuncFromCache(key);\n        let action;\n        if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            const predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                const orgLookaheadFunction = lookaheadFunction;\n                lookaheadFunction = () => {\n                    return predicate.call(this) && orgLookaheadFunction.call(this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        let notStuck = true;\n        while (lookaheadFunction.call(this) === true && notStuck === true) {\n            notStuck = this.doSingleRepetition(action);\n        }\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, keys_1.MANY_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManyWalker, \n        // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n        // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n        // An infinite loop cannot occur as:\n        // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n        // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n        notStuck);\n    }\n    manySepFirstInternal(prodOccurrence, options) {\n        const laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_SEP_IDX, prodOccurrence);\n        this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n    }\n    manySepFirstInternalLogic(prodOccurrence, options, key) {\n        const action = options.DEF;\n        const separator = options.SEP;\n        const firstIterationLaFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLaFunc.call(this) === true) {\n            action.call(this);\n            const separatorLookAheadFunc = () => {\n                return this.tokenMatcher(this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                // No need for checking infinite loop here due to consuming the separator.\n                action.call(this);\n            }\n            // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                interpreter_1.NextTerminalAfterManySepWalker\n            ], separatorLookAheadFunc, keys_1.MANY_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManySepWalker);\n        }\n    }\n    repetitionSepSecondInternal(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n        while (separatorLookAheadFunc()) {\n            // note that this CONSUME will never enter recovery because\n            // the separatorLookAheadFunc checks that the separator really does exist.\n            this.CONSUME(separator);\n            action.call(this);\n        }\n        // we can only arrive to this function after an error\n        // has occurred (hence the name 'second') so the following\n        // IF will always be entered, its possible to remove it...\n        // however it is kept to avoid confusion and be consistent.\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        /* istanbul ignore else */\n        this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n            prodOccurrence,\n            separator,\n            separatorLookAheadFunc,\n            action,\n            nextTerminalAfterWalker\n        ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n    }\n    doSingleRepetition(action) {\n        const beforeIteration = this.getLexerPosition();\n        action.call(this);\n        const afterIteration = this.getLexerPosition();\n        // This boolean will indicate if this repetition progressed\n        // or if we are \"stuck\" (potential infinite loop in the repetition).\n        return afterIteration > beforeIteration;\n    }\n    orInternal(altsOrOpts, occurrence) {\n        const laKey = this.getKeyForAutomaticLookahead(keys_1.OR_IDX, occurrence);\n        const alts = (0, isArray_1.default)(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n        const laFunc = this.getLaFuncFromCache(laKey);\n        const altIdxToTake = laFunc.call(this, alts);\n        if (altIdxToTake !== undefined) {\n            const chosenAlternative = alts[altIdxToTake];\n            return chosenAlternative.ALT.call(this);\n        }\n        this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n    }\n    ruleFinallyStateUpdate() {\n        this.RULE_STACK.pop();\n        this.RULE_OCCURRENCE_STACK.pop();\n        // NOOP when cst is disabled\n        this.cstFinallyStateUpdate();\n        if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n            const firstRedundantTok = this.LA(1);\n            const errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n                firstRedundant: firstRedundantTok,\n                ruleName: this.getCurrRuleFullName()\n            });\n            this.SAVE_ERROR(new exceptions_public_1.NotAllInputParsedException(errMsg, firstRedundantTok));\n        }\n    }\n    subruleInternal(ruleToCall, idx, options) {\n        let ruleResult;\n        try {\n            const args = options !== undefined ? options.ARGS : undefined;\n            this.subruleIdx = idx;\n            ruleResult = ruleToCall.apply(this, args);\n            this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleToCall.ruleName);\n            return ruleResult;\n        }\n        catch (e) {\n            throw this.subruleInternalError(e, options, ruleToCall.ruleName);\n        }\n    }\n    subruleInternalError(e, options, ruleName) {\n        if ((0, exceptions_public_1.isRecognitionException)(e) && e.partialCstResult !== undefined) {\n            this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleName);\n            delete e.partialCstResult;\n        }\n        throw e;\n    }\n    consumeInternal(tokType, idx, options) {\n        let consumedToken;\n        try {\n            const nextToken = this.LA(1);\n            if (this.tokenMatcher(nextToken, tokType) === true) {\n                this.consumeToken();\n                consumedToken = nextToken;\n            }\n            else {\n                this.consumeInternalError(tokType, nextToken, options);\n            }\n        }\n        catch (eFromConsumption) {\n            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n        }\n        this.cstPostTerminal(options !== undefined && options.LABEL !== undefined\n            ? options.LABEL\n            : tokType.name, consumedToken);\n        return consumedToken;\n    }\n    consumeInternalError(tokType, nextToken, options) {\n        let msg;\n        const previousToken = this.LA(0);\n        if (options !== undefined && options.ERR_MSG) {\n            msg = options.ERR_MSG;\n        }\n        else {\n            msg = this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: tokType,\n                actual: nextToken,\n                previous: previousToken,\n                ruleName: this.getCurrRuleFullName()\n            });\n        }\n        throw this.SAVE_ERROR(new exceptions_public_1.MismatchedTokenException(msg, nextToken, previousToken));\n    }\n    consumeInternalRecovery(tokType, idx, eFromConsumption) {\n        // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n        // but the original syntax could have been parsed successfully without any backtracking + recovery\n        if (this.recoveryEnabled &&\n            // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n            eFromConsumption.name === \"MismatchedTokenException\" &&\n            !this.isBackTracking()) {\n            const follows = this.getFollowsForInRuleRecovery(tokType, idx);\n            try {\n                return this.tryInRuleRecovery(tokType, follows);\n            }\n            catch (eFromInRuleRecovery) {\n                if (eFromInRuleRecovery.name === recoverable_1.IN_RULE_RECOVERY_EXCEPTION) {\n                    // failed in RuleRecovery.\n                    // throw the original error in order to trigger reSync error recovery\n                    throw eFromConsumption;\n                }\n                else {\n                    throw eFromInRuleRecovery;\n                }\n            }\n        }\n        else {\n            throw eFromConsumption;\n        }\n    }\n    saveRecogState() {\n        // errors is a getter which will clone the errors array\n        const savedErrors = this.errors;\n        const savedRuleStack = (0, clone_1.default)(this.RULE_STACK);\n        return {\n            errors: savedErrors,\n            lexerState: this.exportLexerState(),\n            RULE_STACK: savedRuleStack,\n            CST_STACK: this.CST_STACK\n        };\n    }\n    reloadRecogState(newState) {\n        this.errors = newState.errors;\n        this.importLexerState(newState.lexerState);\n        this.RULE_STACK = newState.RULE_STACK;\n    }\n    ruleInvocationStateUpdate(shortName, fullName, idxInCallingRule) {\n        this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n        this.RULE_STACK.push(shortName);\n        // NOOP when cst is disabled\n        this.cstInvocationStateUpdate(fullName);\n    }\n    isBackTracking() {\n        return this.isBackTrackingStack.length !== 0;\n    }\n    getCurrRuleFullName() {\n        const shortName = this.getLastExplicitRuleShortName();\n        return this.shortRuleNameToFull[shortName];\n    }\n    shortRuleNameToFullName(shortName) {\n        return this.shortRuleNameToFull[shortName];\n    }\n    isAtEndOfInput() {\n        return this.tokenMatcher(this.LA(1), tokens_public_1.EOF);\n    }\n    reset() {\n        this.resetLexerState();\n        this.subruleIdx = 0;\n        this.isBackTrackingStack = [];\n        this.errors = [];\n        this.RULE_STACK = [];\n        // TODO: extract a specific reset for TreeBuilder trait\n        this.CST_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n    }\n}\nexports.RecognizerEngine = RecognizerEngine;\n//# sourceMappingURL=recognizer_engine.js.map"]},"metadata":{},"sourceType":"script"}