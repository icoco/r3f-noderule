{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkPrefixAlternativesAmbiguities = exports.validateSomeNonEmptyLookaheadPath = exports.validateTooManyAlts = exports.RepetitionCollector = exports.validateAmbiguousAlternationAlternatives = exports.validateEmptyOrAlternative = exports.getFirstNoneTerminal = exports.validateNoLeftRecursion = exports.validateRuleIsOverridden = exports.validateRuleDoesNotAlreadyExist = exports.OccurrenceValidationCollector = exports.identifyProductionForDuplicates = exports.validateGrammar = void 0;\n\nconst first_1 = __importDefault(require(\"lodash/first\"));\n\nconst isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\n\nconst drop_1 = __importDefault(require(\"lodash/drop\"));\n\nconst flatten_1 = __importDefault(require(\"lodash/flatten\"));\n\nconst filter_1 = __importDefault(require(\"lodash/filter\"));\n\nconst reject_1 = __importDefault(require(\"lodash/reject\"));\n\nconst difference_1 = __importDefault(require(\"lodash/difference\"));\n\nconst map_1 = __importDefault(require(\"lodash/map\"));\n\nconst forEach_1 = __importDefault(require(\"lodash/forEach\"));\n\nconst groupBy_1 = __importDefault(require(\"lodash/groupBy\"));\n\nconst reduce_1 = __importDefault(require(\"lodash/reduce\"));\n\nconst pickBy_1 = __importDefault(require(\"lodash/pickBy\"));\n\nconst values_1 = __importDefault(require(\"lodash/values\"));\n\nconst includes_1 = __importDefault(require(\"lodash/includes\"));\n\nconst flatMap_1 = __importDefault(require(\"lodash/flatMap\"));\n\nconst clone_1 = __importDefault(require(\"lodash/clone\"));\n\nconst parser_1 = require(\"../parser/parser\");\n\nconst gast_1 = require(\"@chevrotain/gast\");\n\nconst lookahead_1 = require(\"./lookahead\");\n\nconst interpreter_1 = require(\"./interpreter\");\n\nconst gast_2 = require(\"@chevrotain/gast\");\n\nconst gast_3 = require(\"@chevrotain/gast\");\n\nconst dropRight_1 = __importDefault(require(\"lodash/dropRight\"));\n\nconst compact_1 = __importDefault(require(\"lodash/compact\"));\n\nconst tokens_1 = require(\"../../scan/tokens\");\n\nfunction validateGrammar(topLevels, globalMaxLookahead, tokenTypes, errMsgProvider, grammarName) {\n  const duplicateErrors = (0, flatMap_1.default)(topLevels, currTopLevel => validateDuplicateProductions(currTopLevel, errMsgProvider));\n  const leftRecursionErrors = (0, flatMap_1.default)(topLevels, currTopRule => validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider));\n  let emptyAltErrors = [];\n  let ambiguousAltsErrors = [];\n  let emptyRepetitionErrors = []; // left recursion could cause infinite loops in the following validations.\n  // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\n\n  if ((0, isEmpty_1.default)(leftRecursionErrors)) {\n    emptyAltErrors = (0, flatMap_1.default)(topLevels, currTopRule => validateEmptyOrAlternative(currTopRule, errMsgProvider));\n    ambiguousAltsErrors = (0, flatMap_1.default)(topLevels, currTopRule => validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, errMsgProvider));\n    emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);\n  }\n\n  const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n  const tooManyAltsErrors = (0, flatMap_1.default)(topLevels, curRule => validateTooManyAlts(curRule, errMsgProvider));\n  const duplicateRulesError = (0, flatMap_1.default)(topLevels, curRule => validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider));\n  return duplicateErrors.concat(emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);\n}\n\nexports.validateGrammar = validateGrammar;\n\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n  const collectorVisitor = new OccurrenceValidationCollector();\n  topLevelRule.accept(collectorVisitor);\n  const allRuleProductions = collectorVisitor.allProductions;\n  const productionGroups = (0, groupBy_1.default)(allRuleProductions, identifyProductionForDuplicates);\n  const duplicates = (0, pickBy_1.default)(productionGroups, currGroup => {\n    return currGroup.length > 1;\n  });\n  const errors = (0, map_1.default)((0, values_1.default)(duplicates), currDuplicates => {\n    const firstProd = (0, first_1.default)(currDuplicates);\n    const msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n    const dslName = (0, gast_1.getProductionDslName)(firstProd);\n    const defError = {\n      message: msg,\n      type: parser_1.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    };\n    const param = getExtraProductionArgument(firstProd);\n\n    if (param) {\n      defError.parameter = param;\n    }\n\n    return defError;\n  });\n  return errors;\n}\n\nfunction identifyProductionForDuplicates(prod) {\n  return `${(0, gast_1.getProductionDslName)(prod)}_#_${prod.idx}_#_${getExtraProductionArgument(prod)}`;\n}\n\nexports.identifyProductionForDuplicates = identifyProductionForDuplicates;\n\nfunction getExtraProductionArgument(prod) {\n  if (prod instanceof gast_2.Terminal) {\n    return prod.terminalType.name;\n  } else if (prod instanceof gast_2.NonTerminal) {\n    return prod.nonTerminalName;\n  } else {\n    return \"\";\n  }\n}\n\nclass OccurrenceValidationCollector extends gast_3.GAstVisitor {\n  constructor() {\n    super(...arguments);\n    this.allProductions = [];\n  }\n\n  visitNonTerminal(subrule) {\n    this.allProductions.push(subrule);\n  }\n\n  visitOption(option) {\n    this.allProductions.push(option);\n  }\n\n  visitRepetitionWithSeparator(manySep) {\n    this.allProductions.push(manySep);\n  }\n\n  visitRepetitionMandatory(atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  }\n\n  visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  }\n\n  visitRepetition(many) {\n    this.allProductions.push(many);\n  }\n\n  visitAlternation(or) {\n    this.allProductions.push(or);\n  }\n\n  visitTerminal(terminal) {\n    this.allProductions.push(terminal);\n  }\n\n}\n\nexports.OccurrenceValidationCollector = OccurrenceValidationCollector;\n\nfunction validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n  const errors = [];\n  const occurrences = (0, reduce_1.default)(allRules, (result, curRule) => {\n    if (curRule.name === rule.name) {\n      return result + 1;\n    }\n\n    return result;\n  }, 0);\n\n  if (occurrences > 1) {\n    const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    });\n    errors.push({\n      message: errMsg,\n      type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    });\n  }\n\n  return errors;\n}\n\nexports.validateRuleDoesNotAlreadyExist = validateRuleDoesNotAlreadyExist; // TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\n\nfunction validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n  const errors = [];\n  let errMsg;\n\n  if (!(0, includes_1.default)(definedRulesNames, ruleName)) {\n    errMsg = `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-` + `as it is not defined in any of the super grammars `;\n    errors.push({\n      message: errMsg,\n      type: parser_1.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    });\n  }\n\n  return errors;\n}\n\nexports.validateRuleIsOverridden = validateRuleIsOverridden;\n\nfunction validateNoLeftRecursion(topRule, currRule, errMsgProvider, path = []) {\n  const errors = [];\n  const nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n\n  if ((0, isEmpty_1.default)(nextNonTerminals)) {\n    return [];\n  } else {\n    const ruleName = topRule.name;\n    const foundLeftRecursion = (0, includes_1.default)(nextNonTerminals, topRule);\n\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: parser_1.ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      });\n    } // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n\n\n    const validNextSteps = (0, difference_1.default)(nextNonTerminals, path.concat([topRule]));\n    const errorsFromNextSteps = (0, flatMap_1.default)(validNextSteps, currRefRule => {\n      const newPath = (0, clone_1.default)(path);\n      newPath.push(currRefRule);\n      return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n    });\n    return errors.concat(errorsFromNextSteps);\n  }\n}\n\nexports.validateNoLeftRecursion = validateNoLeftRecursion;\n\nfunction getFirstNoneTerminal(definition) {\n  let result = [];\n\n  if ((0, isEmpty_1.default)(definition)) {\n    return result;\n  }\n\n  const firstProd = (0, first_1.default)(definition);\n  /* istanbul ignore else */\n\n  if (firstProd instanceof gast_2.NonTerminal) {\n    result.push(firstProd.referencedRule);\n  } else if (firstProd instanceof gast_2.Alternative || firstProd instanceof gast_2.Option || firstProd instanceof gast_2.RepetitionMandatory || firstProd instanceof gast_2.RepetitionMandatoryWithSeparator || firstProd instanceof gast_2.RepetitionWithSeparator || firstProd instanceof gast_2.Repetition) {\n    result = result.concat(getFirstNoneTerminal(firstProd.definition));\n  } else if (firstProd instanceof gast_2.Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = (0, flatten_1.default)((0, map_1.default)(firstProd.definition, currSubDef => getFirstNoneTerminal(currSubDef.definition)));\n  } else if (firstProd instanceof gast_2.Terminal) {// nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n\n  const isFirstOptional = (0, gast_1.isOptionalProd)(firstProd);\n  const hasMore = definition.length > 1;\n\n  if (isFirstOptional && hasMore) {\n    const rest = (0, drop_1.default)(definition);\n    return result.concat(getFirstNoneTerminal(rest));\n  } else {\n    return result;\n  }\n}\n\nexports.getFirstNoneTerminal = getFirstNoneTerminal;\n\nclass OrCollector extends gast_3.GAstVisitor {\n  constructor() {\n    super(...arguments);\n    this.alternations = [];\n  }\n\n  visitAlternation(node) {\n    this.alternations.push(node);\n  }\n\n}\n\nfunction validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n  const orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  const ors = orCollector.alternations;\n  const errors = (0, flatMap_1.default)(ors, currOr => {\n    const exceptLast = (0, dropRight_1.default)(currOr.definition);\n    return (0, flatMap_1.default)(exceptLast, (currAlternative, currAltIdx) => {\n      const possibleFirstInAlt = (0, interpreter_1.nextPossibleTokensAfter)([currAlternative], [], tokens_1.tokenStructuredMatcher, 1);\n\n      if ((0, isEmpty_1.default)(possibleFirstInAlt)) {\n        return [{\n          message: errMsgProvider.buildEmptyAlternationError({\n            topLevelRule: topLevelRule,\n            alternation: currOr,\n            emptyChoiceIdx: currAltIdx\n          }),\n          type: parser_1.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx,\n          alternative: currAltIdx + 1\n        }];\n      } else {\n        return [];\n      }\n    });\n  });\n  return errors;\n}\n\nexports.validateEmptyOrAlternative = validateEmptyOrAlternative;\n\nfunction validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n  const orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  let ors = orCollector.alternations; // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n\n  ors = (0, reject_1.default)(ors, currOr => currOr.ignoreAmbiguities === true);\n  const errors = (0, flatMap_1.default)(ors, currOr => {\n    const currOccurrence = currOr.idx;\n    const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n    const alternatives = (0, lookahead_1.getLookaheadPathsForOr)(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n    const altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);\n  });\n  return errors;\n}\n\nexports.validateAmbiguousAlternationAlternatives = validateAmbiguousAlternationAlternatives;\n\nclass RepetitionCollector extends gast_3.GAstVisitor {\n  constructor() {\n    super(...arguments);\n    this.allProductions = [];\n  }\n\n  visitRepetitionWithSeparator(manySep) {\n    this.allProductions.push(manySep);\n  }\n\n  visitRepetitionMandatory(atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  }\n\n  visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  }\n\n  visitRepetition(many) {\n    this.allProductions.push(many);\n  }\n\n}\n\nexports.RepetitionCollector = RepetitionCollector;\n\nfunction validateTooManyAlts(topLevelRule, errMsgProvider) {\n  const orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  const ors = orCollector.alternations;\n  const errors = (0, flatMap_1.default)(ors, currOr => {\n    if (currOr.definition.length > 255) {\n      return [{\n        message: errMsgProvider.buildTooManyAlternativesError({\n          topLevelRule: topLevelRule,\n          alternation: currOr\n        }),\n        type: parser_1.ParserDefinitionErrorType.TOO_MANY_ALTS,\n        ruleName: topLevelRule.name,\n        occurrence: currOr.idx\n      }];\n    } else {\n      return [];\n    }\n  });\n  return errors;\n}\n\nexports.validateTooManyAlts = validateTooManyAlts;\n\nfunction validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n  const errors = [];\n  (0, forEach_1.default)(topLevelRules, currTopRule => {\n    const collectorVisitor = new RepetitionCollector();\n    currTopRule.accept(collectorVisitor);\n    const allRuleProductions = collectorVisitor.allProductions;\n    (0, forEach_1.default)(allRuleProductions, currProd => {\n      const prodType = (0, lookahead_1.getProdType)(currProd);\n      const actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n      const currOccurrence = currProd.idx;\n      const paths = (0, lookahead_1.getLookaheadPathsForOptionalProd)(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n      const pathsInsideProduction = paths[0];\n\n      if ((0, isEmpty_1.default)((0, flatten_1.default)(pathsInsideProduction))) {\n        const errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        });\n        errors.push({\n          message: errMsg,\n          type: parser_1.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        });\n      }\n    });\n  });\n  return errors;\n}\n\nexports.validateSomeNonEmptyLookaheadPath = validateSomeNonEmptyLookaheadPath;\n\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  const foundAmbiguousPaths = [];\n  const identicalAmbiguities = (0, reduce_1.default)(alternatives, (result, currAlt, currAltIdx) => {\n    // ignore (skip) ambiguities with this alternative\n    if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n      return result;\n    }\n\n    (0, forEach_1.default)(currAlt, currPath => {\n      const altsCurrPathAppearsIn = [currAltIdx];\n      (0, forEach_1.default)(alternatives, (currOtherAlt, currOtherAltIdx) => {\n        if (currAltIdx !== currOtherAltIdx && (0, lookahead_1.containsPath)(currOtherAlt, currPath) && // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n          altsCurrPathAppearsIn.push(currOtherAltIdx);\n        }\n      });\n\n      if (altsCurrPathAppearsIn.length > 1 && !(0, lookahead_1.containsPath)(foundAmbiguousPaths, currPath)) {\n        foundAmbiguousPaths.push(currPath);\n        result.push({\n          alts: altsCurrPathAppearsIn,\n          path: currPath\n        });\n      }\n    });\n    return result;\n  }, []);\n  const currErrors = (0, map_1.default)(identicalAmbiguities, currAmbDescriptor => {\n    const ambgIndices = (0, map_1.default)(currAmbDescriptor.alts, currAltIdx => currAltIdx + 1);\n    const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    });\n    return {\n      message: currMessage,\n      type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: currAmbDescriptor.alts\n    };\n  });\n  return currErrors;\n}\n\nfunction checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  // flatten\n  const pathsAndIndices = (0, reduce_1.default)(alternatives, (result, currAlt, idx) => {\n    const currPathsAndIdx = (0, map_1.default)(currAlt, currPath => {\n      return {\n        idx: idx,\n        path: currPath\n      };\n    });\n    return result.concat(currPathsAndIdx);\n  }, []);\n  const errors = (0, compact_1.default)((0, flatMap_1.default)(pathsAndIndices, currPathAndIdx => {\n    const alternativeGast = alternation.definition[currPathAndIdx.idx]; // ignore (skip) ambiguities with this alternative\n\n    if (alternativeGast.ignoreAmbiguities === true) {\n      return [];\n    }\n\n    const targetIdx = currPathAndIdx.idx;\n    const targetPath = currPathAndIdx.path;\n    const prefixAmbiguitiesPathsAndIndices = (0, filter_1.default)(pathsAndIndices, searchPathAndIdx => {\n      // prefix ambiguity can only be created from lower idx (higher priority) path\n      return (// ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx && // checking for strict prefix because identical lookaheads\n        // will be be detected using a different validation.\n        (0, lookahead_1.isStrictPrefixOfPath)(searchPathAndIdx.path, targetPath)\n      );\n    });\n    const currPathPrefixErrors = (0, map_1.default)(prefixAmbiguitiesPathsAndIndices, currAmbPathAndIdx => {\n      const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n      const occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n      const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n        topLevelRule: rule,\n        alternation: alternation,\n        ambiguityIndices: ambgIndices,\n        prefixPath: currAmbPathAndIdx.path\n      });\n      return {\n        message: message,\n        type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n        ruleName: rule.name,\n        occurrence: occurrence,\n        alternatives: ambgIndices\n      };\n    });\n    return currPathPrefixErrors;\n  }));\n  return errors;\n}\n\nexports.checkPrefixAlternativesAmbiguities = checkPrefixAlternativesAmbiguities;\n\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n  const errors = [];\n  const tokenNames = (0, map_1.default)(tokenTypes, currToken => currToken.name);\n  (0, forEach_1.default)(topLevels, currRule => {\n    const currRuleName = currRule.name;\n\n    if ((0, includes_1.default)(tokenNames, currRuleName)) {\n      const errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n      errors.push({\n        message: errMsg,\n        type: parser_1.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      });\n    }\n  });\n  return errors;\n}","map":{"version":3,"sources":["../../../../src/parse/grammar/checks.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,MAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;AACA,MAAA,SAAA,GAAA,eAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,CAAA;;AACA,MAAA,MAAA,GAAA,eAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAA;;AACA,MAAA,SAAA,GAAA,eAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,CAAA;;AACA,MAAA,QAAA,GAAA,eAAA,CAAA,OAAA,CAAA,eAAA,CAAA,CAAA;;AACA,MAAA,QAAA,GAAA,eAAA,CAAA,OAAA,CAAA,eAAA,CAAA,CAAA;;AACA,MAAA,YAAA,GAAA,eAAA,CAAA,OAAA,CAAA,mBAAA,CAAA,CAAA;;AACA,MAAA,KAAA,GAAA,eAAA,CAAA,OAAA,CAAA,YAAA,CAAA,CAAA;;AACA,MAAA,SAAA,GAAA,eAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,CAAA;;AACA,MAAA,SAAA,GAAA,eAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,CAAA;;AACA,MAAA,QAAA,GAAA,eAAA,CAAA,OAAA,CAAA,eAAA,CAAA,CAAA;;AACA,MAAA,QAAA,GAAA,eAAA,CAAA,OAAA,CAAA,eAAA,CAAA,CAAA;;AACA,MAAA,QAAA,GAAA,eAAA,CAAA,OAAA,CAAA,eAAA,CAAA,CAAA;;AACA,MAAA,UAAA,GAAA,eAAA,CAAA,OAAA,CAAA,iBAAA,CAAA,CAAA;;AACA,MAAA,SAAA,GAAA,eAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,CAAA;;AACA,MAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AAMA,MAAA,MAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAQA,MAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AAYA,MAAA,MAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AAUA,MAAA,WAAA,GAAA,eAAA,CAAA,OAAA,CAAA,kBAAA,CAAA,CAAA;;AACA,MAAA,SAAA,GAAA,eAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AAEA,SAAgB,eAAhB,CACE,SADF,EAEE,kBAFF,EAGE,UAHF,EAIE,cAJF,EAKE,WALF,EAKqB;AAEnB,QAAM,eAAe,GAAG,CAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,SAAR,EAAoB,YAAD,IACzC,4BAA4B,CAAC,YAAD,EAAe,cAAf,CADN,CAAxB;AAGA,QAAM,mBAAmB,GAAG,CAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,SAAR,EAAoB,WAAD,IAC7C,uBAAuB,CAAC,WAAD,EAAc,WAAd,EAA2B,cAA3B,CADG,CAA5B;AAIA,MAAI,cAAc,GAA6C,EAA/D;AACA,MAAI,mBAAmB,GAAkD,EAAzE;AACA,MAAI,qBAAqB,GAA6B,EAAtD,CAXmB,CAanB;AACA;;AACA,MAAI,CAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,mBAAR,CAAJ,EAAkC;AAChC,IAAA,cAAc,GAAG,CAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,SAAR,EAAoB,WAAD,IAClC,0BAA0B,CAAC,WAAD,EAAc,cAAd,CADX,CAAjB;AAGA,IAAA,mBAAmB,GAAG,CAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,SAAR,EAAoB,WAAD,IACvC,wCAAwC,CACtC,WADsC,EAEtC,kBAFsC,EAGtC,cAHsC,CADpB,CAAtB;AAQA,IAAA,qBAAqB,GAAG,iCAAiC,CACvD,SADuD,EAEvD,kBAFuD,EAGvD,cAHuD,CAAzD;AAKD;;AAED,QAAM,4BAA4B,GAAG,sCAAsC,CACzE,SADyE,EAEzE,UAFyE,EAGzE,cAHyE,CAA3E;AAMA,QAAM,iBAAiB,GAAG,CAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,SAAR,EAAoB,OAAD,IAC3C,mBAAmB,CAAC,OAAD,EAAU,cAAV,CADK,CAA1B;AAIA,QAAM,mBAAmB,GAAG,CAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,SAAR,EAAoB,OAAD,IAC7C,+BAA+B,CAC7B,OAD6B,EAE7B,SAF6B,EAG7B,WAH6B,EAI7B,cAJ6B,CADL,CAA5B;AASA,SAAQ,eAA4C,CAAC,MAA7C,CACN,qBADM,EAEN,mBAFM,EAGN,cAHM,EAIN,mBAJM,EAKN,4BALM,EAMN,iBANM,EAON,mBAPM,CAAR;AASD;;AAnED,OAAA,CAAA,eAAA,GAAA,eAAA;;AAqEA,SAAS,4BAAT,CACE,YADF,EAEE,cAFF,EAEuD;AAErD,QAAM,gBAAgB,GAAG,IAAI,6BAAJ,EAAzB;AACA,EAAA,YAAY,CAAC,MAAb,CAAoB,gBAApB;AACA,QAAM,kBAAkB,GAAG,gBAAgB,CAAC,cAA5C;AAEA,QAAM,gBAAgB,GAAG,CAAA,GAAA,SAAA,CAAA,OAAA,EACvB,kBADuB,EAEvB,+BAFuB,CAAzB;AAKA,QAAM,UAAU,GAAQ,CAAA,GAAA,QAAA,CAAA,OAAA,EAAO,gBAAP,EAA0B,SAAD,IAAc;AAC7D,WAAO,SAAS,CAAC,MAAV,GAAmB,CAA1B;AACD,GAFuB,CAAxB;AAIA,QAAM,MAAM,GAAG,CAAA,GAAA,KAAA,CAAA,OAAA,EAAI,CAAA,GAAA,QAAA,CAAA,OAAA,EAAO,UAAP,CAAJ,EAAyB,cAAD,IAAwB;AAC7D,UAAM,SAAS,GAAQ,CAAA,GAAA,OAAA,CAAA,OAAA,EAAM,cAAN,CAAvB;AACA,UAAM,GAAG,GAAG,cAAc,CAAC,wBAAf,CACV,YADU,EAEV,cAFU,CAAZ;AAIA,UAAM,OAAO,GAAG,CAAA,GAAA,MAAA,CAAA,oBAAA,EAAqB,SAArB,CAAhB;AACA,UAAM,QAAQ,GAAqC;AACjD,MAAA,OAAO,EAAE,GADwC;AAEjD,MAAA,IAAI,EAAE,QAAA,CAAA,yBAAA,CAA0B,qBAFiB;AAGjD,MAAA,QAAQ,EAAE,YAAY,CAAC,IAH0B;AAIjD,MAAA,OAAO,EAAE,OAJwC;AAKjD,MAAA,UAAU,EAAE,SAAS,CAAC;AAL2B,KAAnD;AAQA,UAAM,KAAK,GAAG,0BAA0B,CAAC,SAAD,CAAxC;;AACA,QAAI,KAAJ,EAAW;AACT,MAAA,QAAQ,CAAC,SAAT,GAAqB,KAArB;AACD;;AAED,WAAO,QAAP;AACD,GArBc,CAAf;AAsBA,SAAO,MAAP;AACD;;AAED,SAAgB,+BAAhB,CACE,IADF,EACiC;AAE/B,SAAO,GAAG,CAAA,GAAA,MAAA,CAAA,oBAAA,EAAqB,IAArB,CAA0B,MAClC,IAAI,CAAC,GACP,MAAM,0BAA0B,CAAC,IAAD,CAAM,EAFtC;AAGD;;AAND,OAAA,CAAA,+BAAA,GAAA,+BAAA;;AAQA,SAAS,0BAAT,CAAoC,IAApC,EAAmE;AACjE,MAAI,IAAI,YAAY,MAAA,CAAA,QAApB,EAA8B;AAC5B,WAAO,IAAI,CAAC,YAAL,CAAkB,IAAzB;AACD,GAFD,MAEO,IAAI,IAAI,YAAY,MAAA,CAAA,WAApB,EAAiC;AACtC,WAAO,IAAI,CAAC,eAAZ;AACD,GAFM,MAEA;AACL,WAAO,EAAP;AACD;AACF;;AAED,MAAa,6BAAb,SAAmD,MAAA,CAAA,WAAnD,CAA8D;AAA9D,EAAA,WAAA,GAAA;;AACS,SAAA,cAAA,GAA8C,EAA9C;AAmCR;;AAjCQ,EAAA,gBAAgB,CAAC,OAAD,EAAqB;AAC1C,SAAK,cAAL,CAAoB,IAApB,CAAyB,OAAzB;AACD;;AAEM,EAAA,WAAW,CAAC,MAAD,EAAe;AAC/B,SAAK,cAAL,CAAoB,IAApB,CAAyB,MAAzB;AACD;;AAEM,EAAA,4BAA4B,CAAC,OAAD,EAAiC;AAClE,SAAK,cAAL,CAAoB,IAApB,CAAyB,OAAzB;AACD;;AAEM,EAAA,wBAAwB,CAAC,UAAD,EAAgC;AAC7D,SAAK,cAAL,CAAoB,IAApB,CAAyB,UAAzB;AACD;;AAEM,EAAA,qCAAqC,CAC1C,aAD0C,EACK;AAE/C,SAAK,cAAL,CAAoB,IAApB,CAAyB,aAAzB;AACD;;AAEM,EAAA,eAAe,CAAC,IAAD,EAAiB;AACrC,SAAK,cAAL,CAAoB,IAApB,CAAyB,IAAzB;AACD;;AAEM,EAAA,gBAAgB,CAAC,EAAD,EAAgB;AACrC,SAAK,cAAL,CAAoB,IAApB,CAAyB,EAAzB;AACD;;AAEM,EAAA,aAAa,CAAC,QAAD,EAAmB;AACrC,SAAK,cAAL,CAAoB,IAApB,CAAyB,QAAzB;AACD;;AAnC2D;;AAA9D,OAAA,CAAA,6BAAA,GAAA,6BAAA;;AAsCA,SAAgB,+BAAhB,CACE,IADF,EAEE,QAFF,EAGE,SAHF,EAIE,cAJF,EAIuD;AAErD,QAAM,MAAM,GAAG,EAAf;AACA,QAAM,WAAW,GAAG,CAAA,GAAA,QAAA,CAAA,OAAA,EAClB,QADkB,EAElB,CAAC,MAAD,EAAS,OAAT,KAAoB;AAClB,QAAI,OAAO,CAAC,IAAR,KAAiB,IAAI,CAAC,IAA1B,EAAgC;AAC9B,aAAO,MAAM,GAAG,CAAhB;AACD;;AACD,WAAO,MAAP;AACD,GAPiB,EAQlB,CARkB,CAApB;;AAUA,MAAI,WAAW,GAAG,CAAlB,EAAqB;AACnB,UAAM,MAAM,GAAG,cAAc,CAAC,2BAAf,CAA2C;AACxD,MAAA,YAAY,EAAE,IAD0C;AAExD,MAAA,WAAW,EAAE;AAF2C,KAA3C,CAAf;AAIA,IAAA,MAAM,CAAC,IAAP,CAAY;AACV,MAAA,OAAO,EAAE,MADC;AAEV,MAAA,IAAI,EAAE,QAAA,CAAA,yBAAA,CAA0B,mBAFtB;AAGV,MAAA,QAAQ,EAAE,IAAI,CAAC;AAHL,KAAZ;AAKD;;AAED,SAAO,MAAP;AACD;;AA9BD,OAAA,CAAA,+BAAA,GAAA,+BAAA,C,CAgCA;AACA;AACA;;AACA,SAAgB,wBAAhB,CACE,QADF,EAEE,iBAFF,EAGE,SAHF,EAGmB;AAEjB,QAAM,MAAM,GAAG,EAAf;AACA,MAAI,MAAJ;;AAEA,MAAI,CAAC,CAAA,GAAA,UAAA,CAAA,OAAA,EAAS,iBAAT,EAA4B,QAA5B,CAAL,EAA4C;AAC1C,IAAA,MAAM,GACJ,kCAAkC,QAAQ,6CAA6C,SAAS,IAAhG,GACA,oDAFF;AAGA,IAAA,MAAM,CAAC,IAAP,CAAY;AACV,MAAA,OAAO,EAAE,MADC;AAEV,MAAA,IAAI,EAAE,QAAA,CAAA,yBAAA,CAA0B,qBAFtB;AAGV,MAAA,QAAQ,EAAE;AAHA,KAAZ;AAKD;;AAED,SAAO,MAAP;AACD;;AApBD,OAAA,CAAA,wBAAA,GAAA,wBAAA;;AAsBA,SAAgB,uBAAhB,CACE,OADF,EAEE,QAFF,EAGE,cAHF,EAIE,IAAA,GAAe,EAJjB,EAImB;AAEjB,QAAM,MAAM,GAA6B,EAAzC;AACA,QAAM,gBAAgB,GAAG,oBAAoB,CAAC,QAAQ,CAAC,UAAV,CAA7C;;AACA,MAAI,CAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,gBAAR,CAAJ,EAA+B;AAC7B,WAAO,EAAP;AACD,GAFD,MAEO;AACL,UAAM,QAAQ,GAAG,OAAO,CAAC,IAAzB;AACA,UAAM,kBAAkB,GAAG,CAAA,GAAA,UAAA,CAAA,OAAA,EAAc,gBAAd,EAAgC,OAAhC,CAA3B;;AACA,QAAI,kBAAJ,EAAwB;AACtB,MAAA,MAAM,CAAC,IAAP,CAAY;AACV,QAAA,OAAO,EAAE,cAAc,CAAC,uBAAf,CAAuC;AAC9C,UAAA,YAAY,EAAE,OADgC;AAE9C,UAAA,iBAAiB,EAAE;AAF2B,SAAvC,CADC;AAKV,QAAA,IAAI,EAAE,QAAA,CAAA,yBAAA,CAA0B,cALtB;AAMV,QAAA,QAAQ,EAAE;AANA,OAAZ;AAQD,KAZI,CAcL;AACA;;;AACA,UAAM,cAAc,GAAG,CAAA,GAAA,YAAA,CAAA,OAAA,EAAW,gBAAX,EAA6B,IAAI,CAAC,MAAL,CAAY,CAAC,OAAD,CAAZ,CAA7B,CAAvB;AACA,UAAM,mBAAmB,GAAG,CAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,cAAR,EAAyB,WAAD,IAAgB;AAClE,YAAM,OAAO,GAAG,CAAA,GAAA,OAAA,CAAA,OAAA,EAAM,IAAN,CAAhB;AACA,MAAA,OAAO,CAAC,IAAR,CAAa,WAAb;AACA,aAAO,uBAAuB,CAC5B,OAD4B,EAE5B,WAF4B,EAG5B,cAH4B,EAI5B,OAJ4B,CAA9B;AAMD,KAT2B,CAA5B;AAWA,WAAO,MAAM,CAAC,MAAP,CAAc,mBAAd,CAAP;AACD;AACF;;AAxCD,OAAA,CAAA,uBAAA,GAAA,uBAAA;;AA0CA,SAAgB,oBAAhB,CAAqC,UAArC,EAA8D;AAC5D,MAAI,MAAM,GAAW,EAArB;;AACA,MAAI,CAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,UAAR,CAAJ,EAAyB;AACvB,WAAO,MAAP;AACD;;AACD,QAAM,SAAS,GAAG,CAAA,GAAA,OAAA,CAAA,OAAA,EAAM,UAAN,CAAlB;AAEA;;AACA,MAAI,SAAS,YAAY,MAAA,CAAA,WAAzB,EAAsC;AACpC,IAAA,MAAM,CAAC,IAAP,CAAY,SAAS,CAAC,cAAtB;AACD,GAFD,MAEO,IACL,SAAS,YAAY,MAAA,CAAA,WAArB,IACA,SAAS,YAAY,MAAA,CAAA,MADrB,IAEA,SAAS,YAAY,MAAA,CAAA,mBAFrB,IAGA,SAAS,YAAY,MAAA,CAAA,gCAHrB,IAIA,SAAS,YAAY,MAAA,CAAA,uBAJrB,IAKA,SAAS,YAAY,MAAA,CAAA,UANhB,EAOL;AACA,IAAA,MAAM,GAAG,MAAM,CAAC,MAAP,CACP,oBAAoB,CAAgB,SAAS,CAAC,UAA1B,CADb,CAAT;AAGD,GAXM,MAWA,IAAI,SAAS,YAAY,MAAA,CAAA,WAAzB,EAAsC;AAC3C;AACA,IAAA,MAAM,GAAG,CAAA,GAAA,SAAA,CAAA,OAAA,EACP,CAAA,GAAA,KAAA,CAAA,OAAA,EAAI,SAAS,CAAC,UAAd,EAA2B,UAAD,IACxB,oBAAoB,CAAmB,UAAW,CAAC,UAA/B,CADtB,CADO,CAAT;AAKD,GAPM,MAOA,IAAI,SAAS,YAAY,MAAA,CAAA,QAAzB,EAAmC,CACxC;AACD,GAFM,MAEA;AACL,UAAM,KAAK,CAAC,sBAAD,CAAX;AACD;;AAED,QAAM,eAAe,GAAG,CAAA,GAAA,MAAA,CAAA,cAAA,EAAe,SAAf,CAAxB;AACA,QAAM,OAAO,GAAG,UAAU,CAAC,MAAX,GAAoB,CAApC;;AACA,MAAI,eAAe,IAAI,OAAvB,EAAgC;AAC9B,UAAM,IAAI,GAAG,CAAA,GAAA,MAAA,CAAA,OAAA,EAAK,UAAL,CAAb;AACA,WAAO,MAAM,CAAC,MAAP,CAAc,oBAAoB,CAAC,IAAD,CAAlC,CAAP;AACD,GAHD,MAGO;AACL,WAAO,MAAP;AACD;AACF;;AA1CD,OAAA,CAAA,oBAAA,GAAA,oBAAA;;AA4CA,MAAM,WAAN,SAA0B,MAAA,CAAA,WAA1B,CAAqC;AAArC,EAAA,WAAA,GAAA;;AACS,SAAA,YAAA,GAA8B,EAA9B;AAKR;;AAHQ,EAAA,gBAAgB,CAAC,IAAD,EAAkB;AACvC,SAAK,YAAL,CAAkB,IAAlB,CAAuB,IAAvB;AACD;;AALkC;;AAQrC,SAAgB,0BAAhB,CACE,YADF,EAEE,cAFF,EAEuD;AAErD,QAAM,WAAW,GAAG,IAAI,WAAJ,EAApB;AACA,EAAA,YAAY,CAAC,MAAb,CAAoB,WAApB;AACA,QAAM,GAAG,GAAG,WAAW,CAAC,YAAxB;AAEA,QAAM,MAAM,GAAG,CAAA,GAAA,SAAA,CAAA,OAAA,EACb,GADa,EAEZ,MAAD,IAAW;AACT,UAAM,UAAU,GAAG,CAAA,GAAA,WAAA,CAAA,OAAA,EAAU,MAAM,CAAC,UAAjB,CAAnB;AACA,WAAO,CAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,UAAR,EAAoB,CAAC,eAAD,EAAkB,UAAlB,KAAgC;AACzD,YAAM,kBAAkB,GAAG,CAAA,GAAA,aAAA,CAAA,uBAAA,EACzB,CAAC,eAAD,CADyB,EAEzB,EAFyB,EAGzB,QAAA,CAAA,sBAHyB,EAIzB,CAJyB,CAA3B;;AAMA,UAAI,CAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,kBAAR,CAAJ,EAAiC;AAC/B,eAAO,CACL;AACE,UAAA,OAAO,EAAE,cAAc,CAAC,0BAAf,CAA0C;AACjD,YAAA,YAAY,EAAE,YADmC;AAEjD,YAAA,WAAW,EAAE,MAFoC;AAGjD,YAAA,cAAc,EAAE;AAHiC,WAA1C,CADX;AAME,UAAA,IAAI,EAAE,QAAA,CAAA,yBAAA,CAA0B,mBANlC;AAOE,UAAA,QAAQ,EAAE,YAAY,CAAC,IAPzB;AAQE,UAAA,UAAU,EAAE,MAAM,CAAC,GARrB;AASE,UAAA,WAAW,EAAE,UAAU,GAAG;AAT5B,SADK,CAAP;AAaD,OAdD,MAcO;AACL,eAAO,EAAP;AACD;AACF,KAxBM,CAAP;AAyBD,GA7BY,CAAf;AAgCA,SAAO,MAAP;AACD;;AAzCD,OAAA,CAAA,0BAAA,GAAA,0BAAA;;AA2CA,SAAgB,wCAAhB,CACE,YADF,EAEE,kBAFF,EAGE,cAHF,EAGuD;AAErD,QAAM,WAAW,GAAG,IAAI,WAAJ,EAApB;AACA,EAAA,YAAY,CAAC,MAAb,CAAoB,WAApB;AACA,MAAI,GAAG,GAAG,WAAW,CAAC,YAAtB,CAJqD,CAMrD;AACA;;AACA,EAAA,GAAG,GAAG,CAAA,GAAA,QAAA,CAAA,OAAA,EAAO,GAAP,EAAa,MAAD,IAAY,MAAM,CAAC,iBAAP,KAA6B,IAArD,CAAN;AAEA,QAAM,MAAM,GAAG,CAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,GAAR,EAAc,MAAD,IAAwB;AAClD,UAAM,cAAc,GAAG,MAAM,CAAC,GAA9B;AACA,UAAM,kBAAkB,GAAG,MAAM,CAAC,YAAP,IAAuB,kBAAlD;AACA,UAAM,YAAY,GAAG,CAAA,GAAA,WAAA,CAAA,sBAAA,EACnB,cADmB,EAEnB,YAFmB,EAGnB,kBAHmB,EAInB,MAJmB,CAArB;AAMA,UAAM,mBAAmB,GAAG,4BAA4B,CACtD,YADsD,EAEtD,MAFsD,EAGtD,YAHsD,EAItD,cAJsD,CAAxD;AAMA,UAAM,yBAAyB,GAAG,kCAAkC,CAClE,YADkE,EAElE,MAFkE,EAGlE,YAHkE,EAIlE,cAJkE,CAApE;AAOA,WAAO,mBAAmB,CAAC,MAApB,CAA2B,yBAA3B,CAAP;AACD,GAvBc,CAAf;AAyBA,SAAO,MAAP;AACD;;AAvCD,OAAA,CAAA,wCAAA,GAAA,wCAAA;;AAyCA,MAAa,mBAAb,SAAyC,MAAA,CAAA,WAAzC,CAAoD;AAApD,EAAA,WAAA,GAAA;;AACS,SAAA,cAAA,GAEA,EAFA;AAqBR;;AAjBQ,EAAA,4BAA4B,CAAC,OAAD,EAAiC;AAClE,SAAK,cAAL,CAAoB,IAApB,CAAyB,OAAzB;AACD;;AAEM,EAAA,wBAAwB,CAAC,UAAD,EAAgC;AAC7D,SAAK,cAAL,CAAoB,IAApB,CAAyB,UAAzB;AACD;;AAEM,EAAA,qCAAqC,CAC1C,aAD0C,EACK;AAE/C,SAAK,cAAL,CAAoB,IAApB,CAAyB,aAAzB;AACD;;AAEM,EAAA,eAAe,CAAC,IAAD,EAAiB;AACrC,SAAK,cAAL,CAAoB,IAApB,CAAyB,IAAzB;AACD;;AArBiD;;AAApD,OAAA,CAAA,mBAAA,GAAA,mBAAA;;AAwBA,SAAgB,mBAAhB,CACE,YADF,EAEE,cAFF,EAEuD;AAErD,QAAM,WAAW,GAAG,IAAI,WAAJ,EAApB;AACA,EAAA,YAAY,CAAC,MAAb,CAAoB,WAApB;AACA,QAAM,GAAG,GAAG,WAAW,CAAC,YAAxB;AAEA,QAAM,MAAM,GAAG,CAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,GAAR,EAAc,MAAD,IAAW;AACrC,QAAI,MAAM,CAAC,UAAP,CAAkB,MAAlB,GAA2B,GAA/B,EAAoC;AAClC,aAAO,CACL;AACE,QAAA,OAAO,EAAE,cAAc,CAAC,6BAAf,CAA6C;AACpD,UAAA,YAAY,EAAE,YADsC;AAEpD,UAAA,WAAW,EAAE;AAFuC,SAA7C,CADX;AAKE,QAAA,IAAI,EAAE,QAAA,CAAA,yBAAA,CAA0B,aALlC;AAME,QAAA,QAAQ,EAAE,YAAY,CAAC,IANzB;AAOE,QAAA,UAAU,EAAE,MAAM,CAAC;AAPrB,OADK,CAAP;AAWD,KAZD,MAYO;AACL,aAAO,EAAP;AACD;AACF,GAhBc,CAAf;AAkBA,SAAO,MAAP;AACD;;AA3BD,OAAA,CAAA,mBAAA,GAAA,mBAAA;;AA6BA,SAAgB,iCAAhB,CACE,aADF,EAEE,YAFF,EAGE,cAHF,EAGuD;AAErD,QAAM,MAAM,GAA6B,EAAzC;AACA,GAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,aAAR,EAAwB,WAAD,IAAgB;AACrC,UAAM,gBAAgB,GAAG,IAAI,mBAAJ,EAAzB;AACA,IAAA,WAAW,CAAC,MAAZ,CAAmB,gBAAnB;AACA,UAAM,kBAAkB,GAAG,gBAAgB,CAAC,cAA5C;AACA,KAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,kBAAR,EAA6B,QAAD,IAAa;AACvC,YAAM,QAAQ,GAAG,CAAA,GAAA,WAAA,CAAA,WAAA,EAAY,QAAZ,CAAjB;AACA,YAAM,kBAAkB,GAAG,QAAQ,CAAC,YAAT,IAAyB,YAApD;AACA,YAAM,cAAc,GAAG,QAAQ,CAAC,GAAhC;AACA,YAAM,KAAK,GAAG,CAAA,GAAA,WAAA,CAAA,gCAAA,EACZ,cADY,EAEZ,WAFY,EAGZ,QAHY,EAIZ,kBAJY,CAAd;AAMA,YAAM,qBAAqB,GAAG,KAAK,CAAC,CAAD,CAAnC;;AACA,UAAI,CAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,CAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,qBAAR,CAAR,CAAJ,EAA6C;AAC3C,cAAM,MAAM,GAAG,cAAc,CAAC,yBAAf,CAAyC;AACtD,UAAA,YAAY,EAAE,WADwC;AAEtD,UAAA,UAAU,EAAE;AAF0C,SAAzC,CAAf;AAIA,QAAA,MAAM,CAAC,IAAP,CAAY;AACV,UAAA,OAAO,EAAE,MADC;AAEV,UAAA,IAAI,EAAE,QAAA,CAAA,yBAAA,CAA0B,sBAFtB;AAGV,UAAA,QAAQ,EAAE,WAAW,CAAC;AAHZ,SAAZ;AAKD;AACF,KAtBD;AAuBD,GA3BD;AA6BA,SAAO,MAAP;AACD;;AApCD,OAAA,CAAA,iCAAA,GAAA,iCAAA;;AA2CA,SAAS,4BAAT,CACE,YADF,EAEE,WAFF,EAGE,IAHF,EAIE,cAJF,EAIuD;AAErD,QAAM,mBAAmB,GAAgB,EAAzC;AACA,QAAM,oBAAoB,GAAG,CAAA,GAAA,QAAA,CAAA,OAAA,EAC3B,YAD2B,EAE3B,CAAC,MAAD,EAAS,OAAT,EAAkB,UAAlB,KAAgC;AAC9B;AACA,QAAI,WAAW,CAAC,UAAZ,CAAuB,UAAvB,EAAmC,iBAAnC,KAAyD,IAA7D,EAAmE;AACjE,aAAO,MAAP;AACD;;AAED,KAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,OAAR,EAAkB,QAAD,IAAa;AAC5B,YAAM,qBAAqB,GAAG,CAAC,UAAD,CAA9B;AACA,OAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,YAAR,EAAsB,CAAC,YAAD,EAAe,eAAf,KAAkC;AACtD,YACE,UAAU,KAAK,eAAf,IACA,CAAA,GAAA,WAAA,CAAA,YAAA,EAAa,YAAb,EAA2B,QAA3B,CADA,IAEA;AACA,QAAA,WAAW,CAAC,UAAZ,CAAuB,eAAvB,EAAwC,iBAAxC,KAA8D,IAJhE,EAKE;AACA,UAAA,qBAAqB,CAAC,IAAtB,CAA2B,eAA3B;AACD;AACF,OATD;;AAWA,UACE,qBAAqB,CAAC,MAAtB,GAA+B,CAA/B,IACA,CAAC,CAAA,GAAA,WAAA,CAAA,YAAA,EAAa,mBAAb,EAAkC,QAAlC,CAFH,EAGE;AACA,QAAA,mBAAmB,CAAC,IAApB,CAAyB,QAAzB;AACA,QAAA,MAAM,CAAC,IAAP,CAAY;AACV,UAAA,IAAI,EAAE,qBADI;AAEV,UAAA,IAAI,EAAE;AAFI,SAAZ;AAID;AACF,KAvBD;AAwBA,WAAO,MAAP;AACD,GAjC0B,EAkC3B,EAlC2B,CAA7B;AAqCA,QAAM,UAAU,GAAG,CAAA,GAAA,KAAA,CAAA,OAAA,EAAI,oBAAJ,EAA2B,iBAAD,IAAsB;AACjE,UAAM,WAAW,GAAG,CAAA,GAAA,KAAA,CAAA,OAAA,EAClB,iBAAiB,CAAC,IADA,EAEjB,UAAD,IAAgB,UAAU,GAAG,CAFX,CAApB;AAKA,UAAM,WAAW,GAAG,cAAc,CAAC,8BAAf,CAA8C;AAChE,MAAA,YAAY,EAAE,IADkD;AAEhE,MAAA,WAAW,EAAE,WAFmD;AAGhE,MAAA,gBAAgB,EAAE,WAH8C;AAIhE,MAAA,UAAU,EAAE,iBAAiB,CAAC;AAJkC,KAA9C,CAApB;AAOA,WAAO;AACL,MAAA,OAAO,EAAE,WADJ;AAEL,MAAA,IAAI,EAAE,QAAA,CAAA,yBAAA,CAA0B,cAF3B;AAGL,MAAA,QAAQ,EAAE,IAAI,CAAC,IAHV;AAIL,MAAA,UAAU,EAAE,WAAW,CAAC,GAJnB;AAKL,MAAA,YAAY,EAAE,iBAAiB,CAAC;AAL3B,KAAP;AAOD,GApBkB,CAAnB;AAsBA,SAAO,UAAP;AACD;;AAED,SAAgB,kCAAhB,CACE,YADF,EAEE,WAFF,EAGE,IAHF,EAIE,cAJF,EAIuD;AAErD;AACA,QAAM,eAAe,GAAG,CAAA,GAAA,QAAA,CAAA,OAAA,EACtB,YADsB,EAEtB,CAAC,MAAD,EAAS,OAAT,EAAkB,GAAlB,KAAyB;AACvB,UAAM,eAAe,GAAG,CAAA,GAAA,KAAA,CAAA,OAAA,EAAI,OAAJ,EAAc,QAAD,IAAa;AAChD,aAAO;AAAE,QAAA,GAAG,EAAE,GAAP;AAAY,QAAA,IAAI,EAAE;AAAlB,OAAP;AACD,KAFuB,CAAxB;AAGA,WAAO,MAAM,CAAC,MAAP,CAAc,eAAd,CAAP;AACD,GAPqB,EAQtB,EARsB,CAAxB;AAWA,QAAM,MAAM,GAAG,CAAA,GAAA,SAAA,CAAA,OAAA,EACb,CAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,eAAR,EAA0B,cAAD,IAAmB;AAC1C,UAAM,eAAe,GAAG,WAAW,CAAC,UAAZ,CAAuB,cAAc,CAAC,GAAtC,CAAxB,CAD0C,CAE1C;;AACA,QAAI,eAAe,CAAC,iBAAhB,KAAsC,IAA1C,EAAgD;AAC9C,aAAO,EAAP;AACD;;AACD,UAAM,SAAS,GAAG,cAAc,CAAC,GAAjC;AACA,UAAM,UAAU,GAAG,cAAc,CAAC,IAAlC;AAEA,UAAM,gCAAgC,GAAG,CAAA,GAAA,QAAA,CAAA,OAAA,EACvC,eADuC,EAEtC,gBAAD,IAAqB;AACnB;AACA,aACE;AACA,QAAA,WAAW,CAAC,UAAZ,CAAuB,gBAAgB,CAAC,GAAxC,EAA6C,iBAA7C,KACE,IADF,IAEA,gBAAgB,CAAC,GAAjB,GAAuB,SAFvB,IAGA;AACA;AACA,SAAA,GAAA,WAAA,CAAA,oBAAA,EAAqB,gBAAgB,CAAC,IAAtC,EAA4C,UAA5C;AAPF;AASD,KAbsC,CAAzC;AAgBA,UAAM,oBAAoB,GAAG,CAAA,GAAA,KAAA,CAAA,OAAA,EAC3B,gCAD2B,EAE1B,iBAAD,IAAmE;AACjE,YAAM,WAAW,GAAG,CAAC,iBAAiB,CAAC,GAAlB,GAAwB,CAAzB,EAA4B,SAAS,GAAG,CAAxC,CAApB;AACA,YAAM,UAAU,GAAG,WAAW,CAAC,GAAZ,KAAoB,CAApB,GAAwB,EAAxB,GAA6B,WAAW,CAAC,GAA5D;AAEA,YAAM,OAAO,GAAG,cAAc,CAAC,oCAAf,CAAoD;AAClE,QAAA,YAAY,EAAE,IADoD;AAElE,QAAA,WAAW,EAAE,WAFqD;AAGlE,QAAA,gBAAgB,EAAE,WAHgD;AAIlE,QAAA,UAAU,EAAE,iBAAiB,CAAC;AAJoC,OAApD,CAAhB;AAMA,aAAO;AACL,QAAA,OAAO,EAAE,OADJ;AAEL,QAAA,IAAI,EAAE,QAAA,CAAA,yBAAA,CAA0B,qBAF3B;AAGL,QAAA,QAAQ,EAAE,IAAI,CAAC,IAHV;AAIL,QAAA,UAAU,EAAE,UAJP;AAKL,QAAA,YAAY,EAAE;AALT,OAAP;AAOD,KAnB0B,CAA7B;AAsBA,WAAO,oBAAP;AACD,GAhDD,CADa,CAAf;AAoDA,SAAO,MAAP;AACD;;AAvED,OAAA,CAAA,kCAAA,GAAA,kCAAA;;AAyEA,SAAS,sCAAT,CACE,SADF,EAEE,UAFF,EAGE,cAHF,EAGuD;AAErD,QAAM,MAAM,GAA6B,EAAzC;AAEA,QAAM,UAAU,GAAG,CAAA,GAAA,KAAA,CAAA,OAAA,EAAI,UAAJ,EAAiB,SAAD,IAAe,SAAS,CAAC,IAAzC,CAAnB;AAEA,GAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,SAAR,EAAoB,QAAD,IAAa;AAC9B,UAAM,YAAY,GAAG,QAAQ,CAAC,IAA9B;;AACA,QAAI,CAAA,GAAA,UAAA,CAAA,OAAA,EAAS,UAAT,EAAqB,YAArB,CAAJ,EAAwC;AACtC,YAAM,MAAM,GAAG,cAAc,CAAC,2BAAf,CAA2C,QAA3C,CAAf;AAEA,MAAA,MAAM,CAAC,IAAP,CAAY;AACV,QAAA,OAAO,EAAE,MADC;AAEV,QAAA,IAAI,EAAE,QAAA,CAAA,yBAAA,CAA0B,+BAFtB;AAGV,QAAA,QAAQ,EAAE;AAHA,OAAZ;AAKD;AACF,GAXD;AAaA,SAAO,MAAP;AACD","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkPrefixAlternativesAmbiguities = exports.validateSomeNonEmptyLookaheadPath = exports.validateTooManyAlts = exports.RepetitionCollector = exports.validateAmbiguousAlternationAlternatives = exports.validateEmptyOrAlternative = exports.getFirstNoneTerminal = exports.validateNoLeftRecursion = exports.validateRuleIsOverridden = exports.validateRuleDoesNotAlreadyExist = exports.OccurrenceValidationCollector = exports.identifyProductionForDuplicates = exports.validateGrammar = void 0;\nconst first_1 = __importDefault(require(\"lodash/first\"));\nconst isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\nconst drop_1 = __importDefault(require(\"lodash/drop\"));\nconst flatten_1 = __importDefault(require(\"lodash/flatten\"));\nconst filter_1 = __importDefault(require(\"lodash/filter\"));\nconst reject_1 = __importDefault(require(\"lodash/reject\"));\nconst difference_1 = __importDefault(require(\"lodash/difference\"));\nconst map_1 = __importDefault(require(\"lodash/map\"));\nconst forEach_1 = __importDefault(require(\"lodash/forEach\"));\nconst groupBy_1 = __importDefault(require(\"lodash/groupBy\"));\nconst reduce_1 = __importDefault(require(\"lodash/reduce\"));\nconst pickBy_1 = __importDefault(require(\"lodash/pickBy\"));\nconst values_1 = __importDefault(require(\"lodash/values\"));\nconst includes_1 = __importDefault(require(\"lodash/includes\"));\nconst flatMap_1 = __importDefault(require(\"lodash/flatMap\"));\nconst clone_1 = __importDefault(require(\"lodash/clone\"));\nconst parser_1 = require(\"../parser/parser\");\nconst gast_1 = require(\"@chevrotain/gast\");\nconst lookahead_1 = require(\"./lookahead\");\nconst interpreter_1 = require(\"./interpreter\");\nconst gast_2 = require(\"@chevrotain/gast\");\nconst gast_3 = require(\"@chevrotain/gast\");\nconst dropRight_1 = __importDefault(require(\"lodash/dropRight\"));\nconst compact_1 = __importDefault(require(\"lodash/compact\"));\nconst tokens_1 = require(\"../../scan/tokens\");\nfunction validateGrammar(topLevels, globalMaxLookahead, tokenTypes, errMsgProvider, grammarName) {\n    const duplicateErrors = (0, flatMap_1.default)(topLevels, (currTopLevel) => validateDuplicateProductions(currTopLevel, errMsgProvider));\n    const leftRecursionErrors = (0, flatMap_1.default)(topLevels, (currTopRule) => validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider));\n    let emptyAltErrors = [];\n    let ambiguousAltsErrors = [];\n    let emptyRepetitionErrors = [];\n    // left recursion could cause infinite loops in the following validations.\n    // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\n    if ((0, isEmpty_1.default)(leftRecursionErrors)) {\n        emptyAltErrors = (0, flatMap_1.default)(topLevels, (currTopRule) => validateEmptyOrAlternative(currTopRule, errMsgProvider));\n        ambiguousAltsErrors = (0, flatMap_1.default)(topLevels, (currTopRule) => validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, errMsgProvider));\n        emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);\n    }\n    const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n    const tooManyAltsErrors = (0, flatMap_1.default)(topLevels, (curRule) => validateTooManyAlts(curRule, errMsgProvider));\n    const duplicateRulesError = (0, flatMap_1.default)(topLevels, (curRule) => validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider));\n    return duplicateErrors.concat(emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);\n}\nexports.validateGrammar = validateGrammar;\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n    const collectorVisitor = new OccurrenceValidationCollector();\n    topLevelRule.accept(collectorVisitor);\n    const allRuleProductions = collectorVisitor.allProductions;\n    const productionGroups = (0, groupBy_1.default)(allRuleProductions, identifyProductionForDuplicates);\n    const duplicates = (0, pickBy_1.default)(productionGroups, (currGroup) => {\n        return currGroup.length > 1;\n    });\n    const errors = (0, map_1.default)((0, values_1.default)(duplicates), (currDuplicates) => {\n        const firstProd = (0, first_1.default)(currDuplicates);\n        const msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n        const dslName = (0, gast_1.getProductionDslName)(firstProd);\n        const defError = {\n            message: msg,\n            type: parser_1.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n            ruleName: topLevelRule.name,\n            dslName: dslName,\n            occurrence: firstProd.idx\n        };\n        const param = getExtraProductionArgument(firstProd);\n        if (param) {\n            defError.parameter = param;\n        }\n        return defError;\n    });\n    return errors;\n}\nfunction identifyProductionForDuplicates(prod) {\n    return `${(0, gast_1.getProductionDslName)(prod)}_#_${prod.idx}_#_${getExtraProductionArgument(prod)}`;\n}\nexports.identifyProductionForDuplicates = identifyProductionForDuplicates;\nfunction getExtraProductionArgument(prod) {\n    if (prod instanceof gast_2.Terminal) {\n        return prod.terminalType.name;\n    }\n    else if (prod instanceof gast_2.NonTerminal) {\n        return prod.nonTerminalName;\n    }\n    else {\n        return \"\";\n    }\n}\nclass OccurrenceValidationCollector extends gast_3.GAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.allProductions = [];\n    }\n    visitNonTerminal(subrule) {\n        this.allProductions.push(subrule);\n    }\n    visitOption(option) {\n        this.allProductions.push(option);\n    }\n    visitRepetitionWithSeparator(manySep) {\n        this.allProductions.push(manySep);\n    }\n    visitRepetitionMandatory(atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    }\n    visitRepetition(many) {\n        this.allProductions.push(many);\n    }\n    visitAlternation(or) {\n        this.allProductions.push(or);\n    }\n    visitTerminal(terminal) {\n        this.allProductions.push(terminal);\n    }\n}\nexports.OccurrenceValidationCollector = OccurrenceValidationCollector;\nfunction validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n    const errors = [];\n    const occurrences = (0, reduce_1.default)(allRules, (result, curRule) => {\n        if (curRule.name === rule.name) {\n            return result + 1;\n        }\n        return result;\n    }, 0);\n    if (occurrences > 1) {\n        const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n            topLevelRule: rule,\n            grammarName: className\n        });\n        errors.push({\n            message: errMsg,\n            type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n            ruleName: rule.name\n        });\n    }\n    return errors;\n}\nexports.validateRuleDoesNotAlreadyExist = validateRuleDoesNotAlreadyExist;\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nfunction validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n    const errors = [];\n    let errMsg;\n    if (!(0, includes_1.default)(definedRulesNames, ruleName)) {\n        errMsg =\n            `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-` +\n                `as it is not defined in any of the super grammars `;\n        errors.push({\n            message: errMsg,\n            type: parser_1.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n            ruleName: ruleName\n        });\n    }\n    return errors;\n}\nexports.validateRuleIsOverridden = validateRuleIsOverridden;\nfunction validateNoLeftRecursion(topRule, currRule, errMsgProvider, path = []) {\n    const errors = [];\n    const nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n    if ((0, isEmpty_1.default)(nextNonTerminals)) {\n        return [];\n    }\n    else {\n        const ruleName = topRule.name;\n        const foundLeftRecursion = (0, includes_1.default)(nextNonTerminals, topRule);\n        if (foundLeftRecursion) {\n            errors.push({\n                message: errMsgProvider.buildLeftRecursionError({\n                    topLevelRule: topRule,\n                    leftRecursionPath: path\n                }),\n                type: parser_1.ParserDefinitionErrorType.LEFT_RECURSION,\n                ruleName: ruleName\n            });\n        }\n        // we are only looking for cyclic paths leading back to the specific topRule\n        // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n        const validNextSteps = (0, difference_1.default)(nextNonTerminals, path.concat([topRule]));\n        const errorsFromNextSteps = (0, flatMap_1.default)(validNextSteps, (currRefRule) => {\n            const newPath = (0, clone_1.default)(path);\n            newPath.push(currRefRule);\n            return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n        });\n        return errors.concat(errorsFromNextSteps);\n    }\n}\nexports.validateNoLeftRecursion = validateNoLeftRecursion;\nfunction getFirstNoneTerminal(definition) {\n    let result = [];\n    if ((0, isEmpty_1.default)(definition)) {\n        return result;\n    }\n    const firstProd = (0, first_1.default)(definition);\n    /* istanbul ignore else */\n    if (firstProd instanceof gast_2.NonTerminal) {\n        result.push(firstProd.referencedRule);\n    }\n    else if (firstProd instanceof gast_2.Alternative ||\n        firstProd instanceof gast_2.Option ||\n        firstProd instanceof gast_2.RepetitionMandatory ||\n        firstProd instanceof gast_2.RepetitionMandatoryWithSeparator ||\n        firstProd instanceof gast_2.RepetitionWithSeparator ||\n        firstProd instanceof gast_2.Repetition) {\n        result = result.concat(getFirstNoneTerminal(firstProd.definition));\n    }\n    else if (firstProd instanceof gast_2.Alternation) {\n        // each sub definition in alternation is a FLAT\n        result = (0, flatten_1.default)((0, map_1.default)(firstProd.definition, (currSubDef) => getFirstNoneTerminal(currSubDef.definition)));\n    }\n    else if (firstProd instanceof gast_2.Terminal) {\n        // nothing to see, move along\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n    const isFirstOptional = (0, gast_1.isOptionalProd)(firstProd);\n    const hasMore = definition.length > 1;\n    if (isFirstOptional && hasMore) {\n        const rest = (0, drop_1.default)(definition);\n        return result.concat(getFirstNoneTerminal(rest));\n    }\n    else {\n        return result;\n    }\n}\nexports.getFirstNoneTerminal = getFirstNoneTerminal;\nclass OrCollector extends gast_3.GAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.alternations = [];\n    }\n    visitAlternation(node) {\n        this.alternations.push(node);\n    }\n}\nfunction validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n    const orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    const ors = orCollector.alternations;\n    const errors = (0, flatMap_1.default)(ors, (currOr) => {\n        const exceptLast = (0, dropRight_1.default)(currOr.definition);\n        return (0, flatMap_1.default)(exceptLast, (currAlternative, currAltIdx) => {\n            const possibleFirstInAlt = (0, interpreter_1.nextPossibleTokensAfter)([currAlternative], [], tokens_1.tokenStructuredMatcher, 1);\n            if ((0, isEmpty_1.default)(possibleFirstInAlt)) {\n                return [\n                    {\n                        message: errMsgProvider.buildEmptyAlternationError({\n                            topLevelRule: topLevelRule,\n                            alternation: currOr,\n                            emptyChoiceIdx: currAltIdx\n                        }),\n                        type: parser_1.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n                        ruleName: topLevelRule.name,\n                        occurrence: currOr.idx,\n                        alternative: currAltIdx + 1\n                    }\n                ];\n            }\n            else {\n                return [];\n            }\n        });\n    });\n    return errors;\n}\nexports.validateEmptyOrAlternative = validateEmptyOrAlternative;\nfunction validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n    const orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    let ors = orCollector.alternations;\n    // New Handling of ignoring ambiguities\n    // - https://github.com/chevrotain/chevrotain/issues/869\n    ors = (0, reject_1.default)(ors, (currOr) => currOr.ignoreAmbiguities === true);\n    const errors = (0, flatMap_1.default)(ors, (currOr) => {\n        const currOccurrence = currOr.idx;\n        const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n        const alternatives = (0, lookahead_1.getLookaheadPathsForOr)(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n        const altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);\n    });\n    return errors;\n}\nexports.validateAmbiguousAlternationAlternatives = validateAmbiguousAlternationAlternatives;\nclass RepetitionCollector extends gast_3.GAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.allProductions = [];\n    }\n    visitRepetitionWithSeparator(manySep) {\n        this.allProductions.push(manySep);\n    }\n    visitRepetitionMandatory(atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    }\n    visitRepetition(many) {\n        this.allProductions.push(many);\n    }\n}\nexports.RepetitionCollector = RepetitionCollector;\nfunction validateTooManyAlts(topLevelRule, errMsgProvider) {\n    const orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    const ors = orCollector.alternations;\n    const errors = (0, flatMap_1.default)(ors, (currOr) => {\n        if (currOr.definition.length > 255) {\n            return [\n                {\n                    message: errMsgProvider.buildTooManyAlternativesError({\n                        topLevelRule: topLevelRule,\n                        alternation: currOr\n                    }),\n                    type: parser_1.ParserDefinitionErrorType.TOO_MANY_ALTS,\n                    ruleName: topLevelRule.name,\n                    occurrence: currOr.idx\n                }\n            ];\n        }\n        else {\n            return [];\n        }\n    });\n    return errors;\n}\nexports.validateTooManyAlts = validateTooManyAlts;\nfunction validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n    const errors = [];\n    (0, forEach_1.default)(topLevelRules, (currTopRule) => {\n        const collectorVisitor = new RepetitionCollector();\n        currTopRule.accept(collectorVisitor);\n        const allRuleProductions = collectorVisitor.allProductions;\n        (0, forEach_1.default)(allRuleProductions, (currProd) => {\n            const prodType = (0, lookahead_1.getProdType)(currProd);\n            const actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n            const currOccurrence = currProd.idx;\n            const paths = (0, lookahead_1.getLookaheadPathsForOptionalProd)(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n            const pathsInsideProduction = paths[0];\n            if ((0, isEmpty_1.default)((0, flatten_1.default)(pathsInsideProduction))) {\n                const errMsg = errMsgProvider.buildEmptyRepetitionError({\n                    topLevelRule: currTopRule,\n                    repetition: currProd\n                });\n                errors.push({\n                    message: errMsg,\n                    type: parser_1.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n                    ruleName: currTopRule.name\n                });\n            }\n        });\n    });\n    return errors;\n}\nexports.validateSomeNonEmptyLookaheadPath = validateSomeNonEmptyLookaheadPath;\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    const foundAmbiguousPaths = [];\n    const identicalAmbiguities = (0, reduce_1.default)(alternatives, (result, currAlt, currAltIdx) => {\n        // ignore (skip) ambiguities with this alternative\n        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n            return result;\n        }\n        (0, forEach_1.default)(currAlt, (currPath) => {\n            const altsCurrPathAppearsIn = [currAltIdx];\n            (0, forEach_1.default)(alternatives, (currOtherAlt, currOtherAltIdx) => {\n                if (currAltIdx !== currOtherAltIdx &&\n                    (0, lookahead_1.containsPath)(currOtherAlt, currPath) &&\n                    // ignore (skip) ambiguities with this \"other\" alternative\n                    alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n                    altsCurrPathAppearsIn.push(currOtherAltIdx);\n                }\n            });\n            if (altsCurrPathAppearsIn.length > 1 &&\n                !(0, lookahead_1.containsPath)(foundAmbiguousPaths, currPath)) {\n                foundAmbiguousPaths.push(currPath);\n                result.push({\n                    alts: altsCurrPathAppearsIn,\n                    path: currPath\n                });\n            }\n        });\n        return result;\n    }, []);\n    const currErrors = (0, map_1.default)(identicalAmbiguities, (currAmbDescriptor) => {\n        const ambgIndices = (0, map_1.default)(currAmbDescriptor.alts, (currAltIdx) => currAltIdx + 1);\n        const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbDescriptor.path\n        });\n        return {\n            message: currMessage,\n            type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n            ruleName: rule.name,\n            occurrence: alternation.idx,\n            alternatives: currAmbDescriptor.alts\n        };\n    });\n    return currErrors;\n}\nfunction checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    // flatten\n    const pathsAndIndices = (0, reduce_1.default)(alternatives, (result, currAlt, idx) => {\n        const currPathsAndIdx = (0, map_1.default)(currAlt, (currPath) => {\n            return { idx: idx, path: currPath };\n        });\n        return result.concat(currPathsAndIdx);\n    }, []);\n    const errors = (0, compact_1.default)((0, flatMap_1.default)(pathsAndIndices, (currPathAndIdx) => {\n        const alternativeGast = alternation.definition[currPathAndIdx.idx];\n        // ignore (skip) ambiguities with this alternative\n        if (alternativeGast.ignoreAmbiguities === true) {\n            return [];\n        }\n        const targetIdx = currPathAndIdx.idx;\n        const targetPath = currPathAndIdx.path;\n        const prefixAmbiguitiesPathsAndIndices = (0, filter_1.default)(pathsAndIndices, (searchPathAndIdx) => {\n            // prefix ambiguity can only be created from lower idx (higher priority) path\n            return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\n                true &&\n                searchPathAndIdx.idx < targetIdx &&\n                // checking for strict prefix because identical lookaheads\n                // will be be detected using a different validation.\n                (0, lookahead_1.isStrictPrefixOfPath)(searchPathAndIdx.path, targetPath));\n        });\n        const currPathPrefixErrors = (0, map_1.default)(prefixAmbiguitiesPathsAndIndices, (currAmbPathAndIdx) => {\n            const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n            const occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n            const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n                topLevelRule: rule,\n                alternation: alternation,\n                ambiguityIndices: ambgIndices,\n                prefixPath: currAmbPathAndIdx.path\n            });\n            return {\n                message: message,\n                type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n                ruleName: rule.name,\n                occurrence: occurrence,\n                alternatives: ambgIndices\n            };\n        });\n        return currPathPrefixErrors;\n    }));\n    return errors;\n}\nexports.checkPrefixAlternativesAmbiguities = checkPrefixAlternativesAmbiguities;\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n    const errors = [];\n    const tokenNames = (0, map_1.default)(tokenTypes, (currToken) => currToken.name);\n    (0, forEach_1.default)(topLevels, (currRule) => {\n        const currRuleName = currRule.name;\n        if ((0, includes_1.default)(tokenNames, currRuleName)) {\n            const errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n            errors.push({\n                message: errMsg,\n                type: parser_1.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n                ruleName: currRuleName\n            });\n        }\n    });\n    return errors;\n}\n//# sourceMappingURL=checks.js.map"]},"metadata":{},"sourceType":"script"}