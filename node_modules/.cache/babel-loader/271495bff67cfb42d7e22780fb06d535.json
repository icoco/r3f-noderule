{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RestWalker = void 0;\n\nconst drop_1 = __importDefault(require(\"lodash/drop\"));\n\nconst forEach_1 = __importDefault(require(\"lodash/forEach\"));\n\nconst gast_1 = require(\"@chevrotain/gast\");\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\n\n\nclass RestWalker {\n  walk(prod, prevRest = []) {\n    (0, forEach_1.default)(prod.definition, (subProd, index) => {\n      const currRest = (0, drop_1.default)(prod.definition, index + 1);\n      /* istanbul ignore else */\n\n      if (subProd instanceof gast_1.NonTerminal) {\n        this.walkProdRef(subProd, currRest, prevRest);\n      } else if (subProd instanceof gast_1.Terminal) {\n        this.walkTerminal(subProd, currRest, prevRest);\n      } else if (subProd instanceof gast_1.Alternative) {\n        this.walkFlat(subProd, currRest, prevRest);\n      } else if (subProd instanceof gast_1.Option) {\n        this.walkOption(subProd, currRest, prevRest);\n      } else if (subProd instanceof gast_1.RepetitionMandatory) {\n        this.walkAtLeastOne(subProd, currRest, prevRest);\n      } else if (subProd instanceof gast_1.RepetitionMandatoryWithSeparator) {\n        this.walkAtLeastOneSep(subProd, currRest, prevRest);\n      } else if (subProd instanceof gast_1.RepetitionWithSeparator) {\n        this.walkManySep(subProd, currRest, prevRest);\n      } else if (subProd instanceof gast_1.Repetition) {\n        this.walkMany(subProd, currRest, prevRest);\n      } else if (subProd instanceof gast_1.Alternation) {\n        this.walkOr(subProd, currRest, prevRest);\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n  }\n\n  walkTerminal(terminal, currRest, prevRest) {}\n\n  walkProdRef(refProd, currRest, prevRest) {}\n\n  walkFlat(flatProd, currRest, prevRest) {\n    // ABCDEF => after the D the rest is EF\n    const fullOrRest = currRest.concat(prevRest);\n    this.walk(flatProd, fullOrRest);\n  }\n\n  walkOption(optionProd, currRest, prevRest) {\n    // ABC(DE)?F => after the (DE)? the rest is F\n    const fullOrRest = currRest.concat(prevRest);\n    this.walk(optionProd, fullOrRest);\n  }\n\n  walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n    // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n    const fullAtLeastOneRest = [new gast_1.Option({\n      definition: atLeastOneProd.definition\n    })].concat(currRest, prevRest);\n    this.walk(atLeastOneProd, fullAtLeastOneRest);\n  }\n\n  walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n    // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n    const fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n    this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n  }\n\n  walkMany(manyProd, currRest, prevRest) {\n    // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n    const fullManyRest = [new gast_1.Option({\n      definition: manyProd.definition\n    })].concat(currRest, prevRest);\n    this.walk(manyProd, fullManyRest);\n  }\n\n  walkManySep(manySepProd, currRest, prevRest) {\n    // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n    const fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n    this.walk(manySepProd, fullManySepRest);\n  }\n\n  walkOr(orProd, currRest, prevRest) {\n    // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n    const fullOrRest = currRest.concat(prevRest); // walk all different alternatives\n\n    (0, forEach_1.default)(orProd.definition, alt => {\n      // wrapping each alternative in a single definition wrapper\n      // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n      // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n      const prodWrapper = new gast_1.Alternative({\n        definition: [alt]\n      });\n      this.walk(prodWrapper, fullOrRest);\n    });\n  }\n\n}\n\nexports.RestWalker = RestWalker;\n\nfunction restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n  const repSepRest = [new gast_1.Option({\n    definition: [new gast_1.Terminal({\n      terminalType: repSepProd.separator\n    })].concat(repSepProd.definition)\n  })];\n  const fullRepSepRest = repSepRest.concat(currRest, prevRest);\n  return fullRepSepRest;\n}","map":{"version":3,"sources":["../../../../src/parse/grammar/rest.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RestWalker = void 0;\nconst drop_1 = __importDefault(require(\"lodash/drop\"));\nconst forEach_1 = __importDefault(require(\"lodash/forEach\"));\nconst gast_1 = require(\"@chevrotain/gast\");\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\nclass RestWalker {\n    walk(prod, prevRest = []) {\n        (0, forEach_1.default)(prod.definition, (subProd, index) => {\n            const currRest = (0, drop_1.default)(prod.definition, index + 1);\n            /* istanbul ignore else */\n            if (subProd instanceof gast_1.NonTerminal) {\n                this.walkProdRef(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof gast_1.Terminal) {\n                this.walkTerminal(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof gast_1.Alternative) {\n                this.walkFlat(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof gast_1.Option) {\n                this.walkOption(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof gast_1.RepetitionMandatory) {\n                this.walkAtLeastOne(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof gast_1.RepetitionMandatoryWithSeparator) {\n                this.walkAtLeastOneSep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof gast_1.RepetitionWithSeparator) {\n                this.walkManySep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof gast_1.Repetition) {\n                this.walkMany(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof gast_1.Alternation) {\n                this.walkOr(subProd, currRest, prevRest);\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n    }\n    walkTerminal(terminal, currRest, prevRest) { }\n    walkProdRef(refProd, currRest, prevRest) { }\n    walkFlat(flatProd, currRest, prevRest) {\n        // ABCDEF => after the D the rest is EF\n        const fullOrRest = currRest.concat(prevRest);\n        this.walk(flatProd, fullOrRest);\n    }\n    walkOption(optionProd, currRest, prevRest) {\n        // ABC(DE)?F => after the (DE)? the rest is F\n        const fullOrRest = currRest.concat(prevRest);\n        this.walk(optionProd, fullOrRest);\n    }\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n        // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n        const fullAtLeastOneRest = [\n            new gast_1.Option({ definition: atLeastOneProd.definition })\n        ].concat(currRest, prevRest);\n        this.walk(atLeastOneProd, fullAtLeastOneRest);\n    }\n    walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n        // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n        const fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n        this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n    }\n    walkMany(manyProd, currRest, prevRest) {\n        // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n        const fullManyRest = [\n            new gast_1.Option({ definition: manyProd.definition })\n        ].concat(currRest, prevRest);\n        this.walk(manyProd, fullManyRest);\n    }\n    walkManySep(manySepProd, currRest, prevRest) {\n        // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n        const fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n        this.walk(manySepProd, fullManySepRest);\n    }\n    walkOr(orProd, currRest, prevRest) {\n        // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n        const fullOrRest = currRest.concat(prevRest);\n        // walk all different alternatives\n        (0, forEach_1.default)(orProd.definition, (alt) => {\n            // wrapping each alternative in a single definition wrapper\n            // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n            // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n            const prodWrapper = new gast_1.Alternative({ definition: [alt] });\n            this.walk(prodWrapper, fullOrRest);\n        });\n    }\n}\nexports.RestWalker = RestWalker;\nfunction restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n    const repSepRest = [\n        new gast_1.Option({\n            definition: [\n                new gast_1.Terminal({ terminalType: repSepProd.separator })\n            ].concat(repSepProd.definition)\n        })\n    ];\n    const fullRepSepRest = repSepRest.concat(currRest, prevRest);\n    return fullRepSepRest;\n}\n//# sourceMappingURL=rest.js.map"]},"metadata":{},"sourceType":"script"}