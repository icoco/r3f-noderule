{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateRedundantMethods = exports.validateMissingCstMethods = exports.validateVisitor = exports.CstVisitorDefinitionError = exports.createBaseVisitorConstructorWithDefaults = exports.createBaseSemanticVisitorConstructor = exports.defaultVisit = void 0;\n\nconst isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\n\nconst compact_1 = __importDefault(require(\"lodash/compact\"));\n\nconst isArray_1 = __importDefault(require(\"lodash/isArray\"));\n\nconst map_1 = __importDefault(require(\"lodash/map\"));\n\nconst forEach_1 = __importDefault(require(\"lodash/forEach\"));\n\nconst filter_1 = __importDefault(require(\"lodash/filter\"));\n\nconst keys_1 = __importDefault(require(\"lodash/keys\"));\n\nconst isFunction_1 = __importDefault(require(\"lodash/isFunction\"));\n\nconst isUndefined_1 = __importDefault(require(\"lodash/isUndefined\"));\n\nconst includes_1 = __importDefault(require(\"lodash/includes\"));\n\nconst lang_extensions_1 = require(\"../../lang/lang_extensions\");\n\nfunction defaultVisit(ctx, param) {\n  const childrenNames = (0, keys_1.default)(ctx);\n  const childrenNamesLength = childrenNames.length;\n\n  for (let i = 0; i < childrenNamesLength; i++) {\n    const currChildName = childrenNames[i];\n    const currChildArray = ctx[currChildName];\n    const currChildArrayLength = currChildArray.length;\n\n    for (let j = 0; j < currChildArrayLength; j++) {\n      const currChild = currChildArray[j]; // distinction between Tokens Children and CstNode children\n\n      if (currChild.tokenTypeIdx === undefined) {\n        this[currChild.name](currChild.children, param);\n      }\n    }\n  } // defaultVisit does not support generic out param\n\n}\n\nexports.defaultVisit = defaultVisit;\n\nfunction createBaseSemanticVisitorConstructor(grammarName, ruleNames) {\n  const derivedConstructor = function () {}; // can be overwritten according to:\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n  // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n\n\n  (0, lang_extensions_1.defineNameProp)(derivedConstructor, grammarName + \"BaseSemantics\");\n  const semanticProto = {\n    visit: function (cstNode, param) {\n      // enables writing more concise visitor methods when CstNode has only a single child\n      if ((0, isArray_1.default)(cstNode)) {\n        // A CST Node's children dictionary can never have empty arrays as values\n        // If a key is defined there will be at least one element in the corresponding value array.\n        cstNode = cstNode[0];\n      } // enables passing optional CstNodes concisely.\n\n\n      if ((0, isUndefined_1.default)(cstNode)) {\n        return undefined;\n      }\n\n      return this[cstNode.name](cstNode.children, param);\n    },\n    validateVisitor: function () {\n      const semanticDefinitionErrors = validateVisitor(this, ruleNames);\n\n      if (!(0, isEmpty_1.default)(semanticDefinitionErrors)) {\n        const errorMessages = (0, map_1.default)(semanticDefinitionErrors, currDefError => currDefError.msg);\n        throw Error(`Errors Detected in CST Visitor <${this.constructor.name}>:\\n\\t` + `${errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\\t\")}`);\n      }\n    }\n  };\n  derivedConstructor.prototype = semanticProto;\n  derivedConstructor.prototype.constructor = derivedConstructor;\n  derivedConstructor._RULE_NAMES = ruleNames;\n  return derivedConstructor;\n}\n\nexports.createBaseSemanticVisitorConstructor = createBaseSemanticVisitorConstructor;\n\nfunction createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {\n  const derivedConstructor = function () {}; // can be overwritten according to:\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n  // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n\n\n  (0, lang_extensions_1.defineNameProp)(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\");\n  const withDefaultsProto = Object.create(baseConstructor.prototype);\n  (0, forEach_1.default)(ruleNames, ruleName => {\n    withDefaultsProto[ruleName] = defaultVisit;\n  });\n  derivedConstructor.prototype = withDefaultsProto;\n  derivedConstructor.prototype.constructor = derivedConstructor;\n  return derivedConstructor;\n}\n\nexports.createBaseVisitorConstructorWithDefaults = createBaseVisitorConstructorWithDefaults;\nvar CstVisitorDefinitionError;\n\n(function (CstVisitorDefinitionError) {\n  CstVisitorDefinitionError[CstVisitorDefinitionError[\"REDUNDANT_METHOD\"] = 0] = \"REDUNDANT_METHOD\";\n  CstVisitorDefinitionError[CstVisitorDefinitionError[\"MISSING_METHOD\"] = 1] = \"MISSING_METHOD\";\n})(CstVisitorDefinitionError = exports.CstVisitorDefinitionError || (exports.CstVisitorDefinitionError = {}));\n\nfunction validateVisitor(visitorInstance, ruleNames) {\n  const missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);\n  const redundantErrors = validateRedundantMethods(visitorInstance, ruleNames);\n  return missingErrors.concat(redundantErrors);\n}\n\nexports.validateVisitor = validateVisitor;\n\nfunction validateMissingCstMethods(visitorInstance, ruleNames) {\n  const missingRuleNames = (0, filter_1.default)(ruleNames, currRuleName => {\n    return (0, isFunction_1.default)(visitorInstance[currRuleName]) === false;\n  });\n  const errors = (0, map_1.default)(missingRuleNames, currRuleName => {\n    return {\n      msg: `Missing visitor method: <${currRuleName}> on ${visitorInstance.constructor.name} CST Visitor.`,\n      type: CstVisitorDefinitionError.MISSING_METHOD,\n      methodName: currRuleName\n    };\n  });\n  return (0, compact_1.default)(errors);\n}\n\nexports.validateMissingCstMethods = validateMissingCstMethods;\nconst VALID_PROP_NAMES = [\"constructor\", \"visit\", \"validateVisitor\"];\n\nfunction validateRedundantMethods(visitorInstance, ruleNames) {\n  const errors = [];\n  const propNames = Object.getOwnPropertyNames(visitorInstance.constructor.prototype);\n  (0, forEach_1.default)(propNames, prop => {\n    if ((0, isFunction_1.default)(visitorInstance[prop]) && !(0, includes_1.default)(VALID_PROP_NAMES, prop) && !(0, includes_1.default)(ruleNames, prop)) {\n      errors.push({\n        msg: `Redundant visitor method: <${prop}> on ${visitorInstance.constructor.name} CST Visitor\\n` + `There is no Grammar Rule corresponding to this method's name.\\n`,\n        type: CstVisitorDefinitionError.REDUNDANT_METHOD,\n        methodName: prop\n      });\n    }\n  });\n  return errors;\n}\n\nexports.validateRedundantMethods = validateRedundantMethods;","map":{"version":3,"sources":["../../../../src/parse/cst/cst_visitor.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,MAAA,SAAA,GAAA,eAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,CAAA;;AACA,MAAA,SAAA,GAAA,eAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,CAAA;;AACA,MAAA,SAAA,GAAA,eAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,CAAA;;AACA,MAAA,KAAA,GAAA,eAAA,CAAA,OAAA,CAAA,YAAA,CAAA,CAAA;;AACA,MAAA,SAAA,GAAA,eAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,CAAA;;AACA,MAAA,QAAA,GAAA,eAAA,CAAA,OAAA,CAAA,eAAA,CAAA,CAAA;;AACA,MAAA,MAAA,GAAA,eAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAA;;AACA,MAAA,YAAA,GAAA,eAAA,CAAA,OAAA,CAAA,mBAAA,CAAA,CAAA;;AACA,MAAA,aAAA,GAAA,eAAA,CAAA,OAAA,CAAA,oBAAA,CAAA,CAAA;;AACA,MAAA,UAAA,GAAA,eAAA,CAAA,OAAA,CAAA,iBAAA,CAAA,CAAA;;AACA,MAAA,iBAAA,GAAA,OAAA,CAAA,4BAAA,CAAA;;AAGA,SAAgB,YAAhB,CAAiC,GAAjC,EAA2C,KAA3C,EAAoD;AAClD,QAAM,aAAa,GAAG,CAAA,GAAA,MAAA,CAAA,OAAA,EAAK,GAAL,CAAtB;AACA,QAAM,mBAAmB,GAAG,aAAa,CAAC,MAA1C;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,mBAApB,EAAyC,CAAC,EAA1C,EAA8C;AAC5C,UAAM,aAAa,GAAG,aAAa,CAAC,CAAD,CAAnC;AACA,UAAM,cAAc,GAAG,GAAG,CAAC,aAAD,CAA1B;AACA,UAAM,oBAAoB,GAAG,cAAc,CAAC,MAA5C;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,oBAApB,EAA0C,CAAC,EAA3C,EAA+C;AAC7C,YAAM,SAAS,GAAQ,cAAc,CAAC,CAAD,CAArC,CAD6C,CAE7C;;AACA,UAAI,SAAS,CAAC,YAAV,KAA2B,SAA/B,EAA0C;AACxC,aAAK,SAAS,CAAC,IAAf,EAAqB,SAAS,CAAC,QAA/B,EAAyC,KAAzC;AACD;AACF;AACF,GAdiD,CAelD;;AACD;;AAhBD,OAAA,CAAA,YAAA,GAAA,YAAA;;AAkBA,SAAgB,oCAAhB,CACE,WADF,EAEE,SAFF,EAEqB;AAInB,QAAM,kBAAkB,GAAQ,YAAA,CAAc,CAA9C,CAJmB,CAMnB;AACA;AACA;;;AACA,GAAA,GAAA,iBAAA,CAAA,cAAA,EAAe,kBAAf,EAAmC,WAAW,GAAG,eAAjD;AAEA,QAAM,aAAa,GAAG;AACpB,IAAA,KAAK,EAAE,UAAU,OAAV,EAAwC,KAAxC,EAAkD;AACvD;AACA,UAAI,CAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,OAAR,CAAJ,EAAsB;AACpB;AACA;AACA,QAAA,OAAO,GAAG,OAAO,CAAC,CAAD,CAAjB;AACD,OANsD,CAQvD;;;AACA,UAAI,CAAA,GAAA,aAAA,CAAA,OAAA,EAAY,OAAZ,CAAJ,EAA0B;AACxB,eAAO,SAAP;AACD;;AAED,aAAO,KAAK,OAAO,CAAC,IAAb,EAAmB,OAAO,CAAC,QAA3B,EAAqC,KAArC,CAAP;AACD,KAfmB;AAiBpB,IAAA,eAAe,EAAE,YAAA;AACf,YAAM,wBAAwB,GAAG,eAAe,CAAC,IAAD,EAAO,SAAP,CAAhD;;AACA,UAAI,CAAC,CAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,wBAAR,CAAL,EAAwC;AACtC,cAAM,aAAa,GAAG,CAAA,GAAA,KAAA,CAAA,OAAA,EACpB,wBADoB,EAEnB,YAAD,IAAkB,YAAY,CAAC,GAFX,CAAtB;AAIA,cAAM,KAAK,CACT,mCAAmC,KAAK,WAAL,CAAiB,IAAI,QAAxD,GACE,GAAG,aAAa,CAAC,IAAd,CAAmB,MAAnB,EAA2B,OAA3B,CAAmC,KAAnC,EAA0C,MAA1C,CAAiD,EAF7C,CAAX;AAID;AACF;AA7BmB,GAAtB;AAgCA,EAAA,kBAAkB,CAAC,SAAnB,GAA+B,aAA/B;AACA,EAAA,kBAAkB,CAAC,SAAnB,CAA6B,WAA7B,GAA2C,kBAA3C;AAEA,EAAA,kBAAkB,CAAC,WAAnB,GAAiC,SAAjC;AAEA,SAAO,kBAAP;AACD;;AAnDD,OAAA,CAAA,oCAAA,GAAA,oCAAA;;AAqDA,SAAgB,wCAAhB,CACE,WADF,EAEE,SAFF,EAGE,eAHF,EAG2B;AAIzB,QAAM,kBAAkB,GAAQ,YAAA,CAAc,CAA9C,CAJyB,CAMzB;AACA;AACA;;;AACA,GAAA,GAAA,iBAAA,CAAA,cAAA,EAAe,kBAAf,EAAmC,WAAW,GAAG,2BAAjD;AAEA,QAAM,iBAAiB,GAAG,MAAM,CAAC,MAAP,CAAc,eAAe,CAAC,SAA9B,CAA1B;AACA,GAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,SAAR,EAAoB,QAAD,IAAa;AAC9B,IAAA,iBAAiB,CAAC,QAAD,CAAjB,GAA8B,YAA9B;AACD,GAFD;AAIA,EAAA,kBAAkB,CAAC,SAAnB,GAA+B,iBAA/B;AACA,EAAA,kBAAkB,CAAC,SAAnB,CAA6B,WAA7B,GAA2C,kBAA3C;AAEA,SAAO,kBAAP;AACD;;AAvBD,OAAA,CAAA,wCAAA,GAAA,wCAAA;AAyBA,IAAY,yBAAZ;;AAAA,CAAA,UAAY,yBAAZ,EAAqC;AACnC,EAAA,yBAAA,CAAA,yBAAA,CAAA,kBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,kBAAA;AACA,EAAA,yBAAA,CAAA,yBAAA,CAAA,gBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,gBAAA;AACD,CAHD,EAAY,yBAAyB,GAAzB,OAAA,CAAA,yBAAA,KAAA,OAAA,CAAA,yBAAA,GAAyB,EAAzB,CAAZ;;AAWA,SAAgB,eAAhB,CACE,eADF,EAEE,SAFF,EAEqB;AAEnB,QAAM,aAAa,GAAG,yBAAyB,CAAC,eAAD,EAAkB,SAAlB,CAA/C;AACA,QAAM,eAAe,GAAG,wBAAwB,CAAC,eAAD,EAAkB,SAAlB,CAAhD;AAEA,SAAO,aAAa,CAAC,MAAd,CAAqB,eAArB,CAAP;AACD;;AARD,OAAA,CAAA,eAAA,GAAA,eAAA;;AAUA,SAAgB,yBAAhB,CACE,eADF,EAEE,SAFF,EAEqB;AAEnB,QAAM,gBAAgB,GAAG,CAAA,GAAA,QAAA,CAAA,OAAA,EAAO,SAAP,EAAmB,YAAD,IAAiB;AAC1D,WAAO,CAAA,GAAA,YAAA,CAAA,OAAA,EAAY,eAAuB,CAAC,YAAD,CAAnC,MAAuD,KAA9D;AACD,GAFwB,CAAzB;AAIA,QAAM,MAAM,GAA8B,CAAA,GAAA,KAAA,CAAA,OAAA,EACxC,gBADwC,EAEvC,YAAD,IAAiB;AACf,WAAO;AACL,MAAA,GAAG,EAAE,4BAA4B,YAAY,QAC3C,eAAe,CAAC,WAAhB,CAA4B,IAC7B,eAHI;AAIL,MAAA,IAAI,EAAE,yBAAyB,CAAC,cAJ3B;AAKL,MAAA,UAAU,EAAE;AALP,KAAP;AAOD,GAVuC,CAA1C;AAaA,SAAO,CAAA,GAAA,SAAA,CAAA,OAAA,EAAiC,MAAjC,CAAP;AACD;;AAtBD,OAAA,CAAA,yBAAA,GAAA,yBAAA;AAwBA,MAAM,gBAAgB,GAAG,CAAC,aAAD,EAAgB,OAAhB,EAAyB,iBAAzB,CAAzB;;AAEA,SAAgB,wBAAhB,CACE,eADF,EAEE,SAFF,EAEqB;AAEnB,QAAM,MAAM,GAA8B,EAA1C;AACA,QAAM,SAAS,GAAG,MAAM,CAAC,mBAAP,CAChB,eAAe,CAAC,WAAhB,CAA4B,SADZ,CAAlB;AAGA,GAAA,GAAA,SAAA,CAAA,OAAA,EAAQ,SAAR,EAAoB,IAAD,IAAS;AAC1B,QACE,CAAA,GAAA,YAAA,CAAA,OAAA,EAAY,eAAuB,CAAC,IAAD,CAAnC,KACA,CAAC,CAAA,GAAA,UAAA,CAAA,OAAA,EAAS,gBAAT,EAA2B,IAA3B,CADD,IAEA,CAAC,CAAA,GAAA,UAAA,CAAA,OAAA,EAAS,SAAT,EAAoB,IAApB,CAHH,EAIE;AACA,MAAA,MAAM,CAAC,IAAP,CAAY;AACV,QAAA,GAAG,EACD,8BAA8B,IAAI,QAChC,eAAe,CAAC,WAAhB,CAA4B,IAC7B,gBAFD,GAGA,iEALQ;AAMV,QAAA,IAAI,EAAE,yBAAyB,CAAC,gBANtB;AAOV,QAAA,UAAU,EAAE;AAPF,OAAZ;AASD;AACF,GAhBD;AAiBA,SAAO,MAAP;AACD;;AA1BD,OAAA,CAAA,wBAAA,GAAA,wBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateRedundantMethods = exports.validateMissingCstMethods = exports.validateVisitor = exports.CstVisitorDefinitionError = exports.createBaseVisitorConstructorWithDefaults = exports.createBaseSemanticVisitorConstructor = exports.defaultVisit = void 0;\nconst isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\nconst compact_1 = __importDefault(require(\"lodash/compact\"));\nconst isArray_1 = __importDefault(require(\"lodash/isArray\"));\nconst map_1 = __importDefault(require(\"lodash/map\"));\nconst forEach_1 = __importDefault(require(\"lodash/forEach\"));\nconst filter_1 = __importDefault(require(\"lodash/filter\"));\nconst keys_1 = __importDefault(require(\"lodash/keys\"));\nconst isFunction_1 = __importDefault(require(\"lodash/isFunction\"));\nconst isUndefined_1 = __importDefault(require(\"lodash/isUndefined\"));\nconst includes_1 = __importDefault(require(\"lodash/includes\"));\nconst lang_extensions_1 = require(\"../../lang/lang_extensions\");\nfunction defaultVisit(ctx, param) {\n    const childrenNames = (0, keys_1.default)(ctx);\n    const childrenNamesLength = childrenNames.length;\n    for (let i = 0; i < childrenNamesLength; i++) {\n        const currChildName = childrenNames[i];\n        const currChildArray = ctx[currChildName];\n        const currChildArrayLength = currChildArray.length;\n        for (let j = 0; j < currChildArrayLength; j++) {\n            const currChild = currChildArray[j];\n            // distinction between Tokens Children and CstNode children\n            if (currChild.tokenTypeIdx === undefined) {\n                this[currChild.name](currChild.children, param);\n            }\n        }\n    }\n    // defaultVisit does not support generic out param\n}\nexports.defaultVisit = defaultVisit;\nfunction createBaseSemanticVisitorConstructor(grammarName, ruleNames) {\n    const derivedConstructor = function () { };\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    (0, lang_extensions_1.defineNameProp)(derivedConstructor, grammarName + \"BaseSemantics\");\n    const semanticProto = {\n        visit: function (cstNode, param) {\n            // enables writing more concise visitor methods when CstNode has only a single child\n            if ((0, isArray_1.default)(cstNode)) {\n                // A CST Node's children dictionary can never have empty arrays as values\n                // If a key is defined there will be at least one element in the corresponding value array.\n                cstNode = cstNode[0];\n            }\n            // enables passing optional CstNodes concisely.\n            if ((0, isUndefined_1.default)(cstNode)) {\n                return undefined;\n            }\n            return this[cstNode.name](cstNode.children, param);\n        },\n        validateVisitor: function () {\n            const semanticDefinitionErrors = validateVisitor(this, ruleNames);\n            if (!(0, isEmpty_1.default)(semanticDefinitionErrors)) {\n                const errorMessages = (0, map_1.default)(semanticDefinitionErrors, (currDefError) => currDefError.msg);\n                throw Error(`Errors Detected in CST Visitor <${this.constructor.name}>:\\n\\t` +\n                    `${errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\\t\")}`);\n            }\n        }\n    };\n    derivedConstructor.prototype = semanticProto;\n    derivedConstructor.prototype.constructor = derivedConstructor;\n    derivedConstructor._RULE_NAMES = ruleNames;\n    return derivedConstructor;\n}\nexports.createBaseSemanticVisitorConstructor = createBaseSemanticVisitorConstructor;\nfunction createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {\n    const derivedConstructor = function () { };\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    (0, lang_extensions_1.defineNameProp)(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\");\n    const withDefaultsProto = Object.create(baseConstructor.prototype);\n    (0, forEach_1.default)(ruleNames, (ruleName) => {\n        withDefaultsProto[ruleName] = defaultVisit;\n    });\n    derivedConstructor.prototype = withDefaultsProto;\n    derivedConstructor.prototype.constructor = derivedConstructor;\n    return derivedConstructor;\n}\nexports.createBaseVisitorConstructorWithDefaults = createBaseVisitorConstructorWithDefaults;\nvar CstVisitorDefinitionError;\n(function (CstVisitorDefinitionError) {\n    CstVisitorDefinitionError[CstVisitorDefinitionError[\"REDUNDANT_METHOD\"] = 0] = \"REDUNDANT_METHOD\";\n    CstVisitorDefinitionError[CstVisitorDefinitionError[\"MISSING_METHOD\"] = 1] = \"MISSING_METHOD\";\n})(CstVisitorDefinitionError = exports.CstVisitorDefinitionError || (exports.CstVisitorDefinitionError = {}));\nfunction validateVisitor(visitorInstance, ruleNames) {\n    const missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);\n    const redundantErrors = validateRedundantMethods(visitorInstance, ruleNames);\n    return missingErrors.concat(redundantErrors);\n}\nexports.validateVisitor = validateVisitor;\nfunction validateMissingCstMethods(visitorInstance, ruleNames) {\n    const missingRuleNames = (0, filter_1.default)(ruleNames, (currRuleName) => {\n        return (0, isFunction_1.default)(visitorInstance[currRuleName]) === false;\n    });\n    const errors = (0, map_1.default)(missingRuleNames, (currRuleName) => {\n        return {\n            msg: `Missing visitor method: <${currRuleName}> on ${(visitorInstance.constructor.name)} CST Visitor.`,\n            type: CstVisitorDefinitionError.MISSING_METHOD,\n            methodName: currRuleName\n        };\n    });\n    return (0, compact_1.default)(errors);\n}\nexports.validateMissingCstMethods = validateMissingCstMethods;\nconst VALID_PROP_NAMES = [\"constructor\", \"visit\", \"validateVisitor\"];\nfunction validateRedundantMethods(visitorInstance, ruleNames) {\n    const errors = [];\n    const propNames = Object.getOwnPropertyNames(visitorInstance.constructor.prototype);\n    (0, forEach_1.default)(propNames, (prop) => {\n        if ((0, isFunction_1.default)(visitorInstance[prop]) &&\n            !(0, includes_1.default)(VALID_PROP_NAMES, prop) &&\n            !(0, includes_1.default)(ruleNames, prop)) {\n            errors.push({\n                msg: `Redundant visitor method: <${prop}> on ${(visitorInstance.constructor.name)} CST Visitor\\n` +\n                    `There is no Grammar Rule corresponding to this method's name.\\n`,\n                type: CstVisitorDefinitionError.REDUNDANT_METHOD,\n                methodName: prop\n            });\n        }\n    });\n    return errors;\n}\nexports.validateRedundantMethods = validateRedundantMethods;\n//# sourceMappingURL=cst_visitor.js.map"]},"metadata":{},"sourceType":"script"}