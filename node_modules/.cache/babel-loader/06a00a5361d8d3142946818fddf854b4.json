{"ast":null,"code":"import { useCallbackRef as e } from \"@radix-ui/react-use-callback-ref\";\nimport * as t from \"react\";\nexport function useControllableState({\n  prop: o,\n  defaultProp: r,\n  onChange: n = () => {}\n}) {\n  const [a, u] = function ({\n    defaultProp: o,\n    onChange: r\n  }) {\n    const n = t.useState(o),\n          [a] = n,\n          u = t.useRef(a),\n          c = e(r);\n    return t.useEffect(() => {\n      u.current !== a && (c(a), u.current = a);\n    }, [a, u, c]), n;\n  }({\n    defaultProp: r,\n    onChange: n\n  }),\n        c = void 0 !== o,\n        f = c ? o : a,\n        l = e(n);\n\n  return [f, t.useCallback(e => {\n    if (c) {\n      const t = e,\n            r = \"function\" == typeof e ? t(o) : e;\n      r !== o && l(r);\n    } else u(e);\n  }, [c, o, u, l])];\n}","map":{"version":3,"sources":["packages/react/use-controllable-state/src/useControllableState.tsx"],"names":["useControllableState","prop","defaultProp","onChange","uncontrolledProp","setUncontrolledProp","useUncontrolledState","isControlled","undefined","value","handleChange","useCallbackRef","React","useCallback","nextValue","setter","uncontrolledState","useState","prevValueRef","useRef","useEffect","current"],"mappings":";;OAWA,SAASA,oBAAT,CAASA;AAAwBC,EAAAA,IAAAA,EAC/BA,CADOD;AAAwBC,EAAAA,WAAAA,EAE/BC,CAFOF;AAAwBC,EAAAA,QAAAA,EAG/BE,CAAAA,GAAW,MAAA,CAAA;AAHJH,CAAT,EAGa;AAEX,QAAA,CAAOI,CAAP,EAAyBC,CAAzB,IAqBF,UAAA;AAAiCH,IAAAA,WAAAA,EAC/BA,CADF;AAAiCA,IAAAA,QAAAA,EAE/BC;AAFF,GAAA,EAEEA;AAEA,UAAMa,CAAAA,GAAoBJ,CAAAA,CAAMK,QAANL,CAA8BV,CAA9BU,CAA1B;AAAA,UAAwDV,CACjDO,CADiDP,IACxCc,CADhB;AAAA,UAEME,CAAAA,GAAeN,CAAAA,CAAMO,MAANP,CAAaH,CAAbG,CAFrB;AAAA,UAGMF,CAAAA,GAAeC,CAAAA,CAAeR,CAAfQ,CAHrB;AAYA,WAPAC,CAAAA,CAAMQ,SAANR,CAAgB,MAAA;AACVM,MAAAA,CAAAA,CAAaG,OAAbH,KAAyBT,CAAzBS,KACFR,CAAAA,CAAaD,CAAbC,CAAAA,EACAQ,CAAAA,CAAaG,OAAbH,GAAuBT,CAFrBS;AAEqBT,KAH3BG,EAKG,CAACH,CAAD,EAAQS,CAAR,EAAsBR,CAAtB,CALHE,GAOOI,CAAP;AArCgDV,GAqBlD,CArBuE;AAAEJ,IAAAA,WAAAA,EAAAA,CAAF;AAAeC,IAAAA,QAAAA,EAAAA;AAAf,GAqBvE,CArBE;AAAA,QACMI,CAAAA,GAAAA,KAAwBC,CAAxBD,KAAeN,CADrB;AAAA,QAEMQ,CAAAA,GAAQF,CAAAA,GAAeN,CAAfM,GAAsBH,CAFpC;AAAA,QAGMM,CAAAA,GAAeC,CAAAA,CAAeR,CAAfQ,CAHrB;;AAkBA,SAAO,CAACF,CAAD,EAb+DG,CAAAA,CAAMC,WAAND,CACnEE,CAAAA,IAAAA;AACC,QAAIP,CAAJ,EAAkB;AAChB,YAAMQ,CAAAA,GAASD,CAAf;AAAA,YACML,CAAAA,GAA6B,cAAA,OAAdK,CAAc,GAAaC,CAAAA,CAAOd,CAAPc,CAAb,GAA4BD,CAD/D;AAEIL,MAAAA,CAAAA,KAAUR,CAAVQ,IAAgBC,CAAAA,CAAaD,CAAbC,CAAhBD;AAA6BA,KAHnC,MAKEJ,CAAAA,CAAoBS,CAApBT,CAAAA;AAAoBS,GAP4CF,EAUpE,CAACL,CAAD,EAAeN,CAAf,EAAqBI,CAArB,EAA0CK,CAA1C,CAVoEE,CAa/D,CAAP;AAH4CF","sourcesContent":["import * as React from 'react';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\n\ntype UseControllableStateParams<T> = {\n  prop?: T | undefined;\n  defaultProp?: T | undefined;\n  onChange?: (state: T) => void;\n};\n\ntype SetStateFn<T> = (prevState?: T) => T;\n\nfunction useControllableState<T>({\n  prop,\n  defaultProp,\n  onChange = () => {},\n}: UseControllableStateParams<T>) {\n  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });\n  const isControlled = prop !== undefined;\n  const value = isControlled ? prop : uncontrolledProp;\n  const handleChange = useCallbackRef(onChange);\n\n  const setValue: React.Dispatch<React.SetStateAction<T | undefined>> = React.useCallback(\n    (nextValue) => {\n      if (isControlled) {\n        const setter = nextValue as SetStateFn<T>;\n        const value = typeof nextValue === 'function' ? setter(prop) : nextValue;\n        if (value !== prop) handleChange(value as T);\n      } else {\n        setUncontrolledProp(nextValue);\n      }\n    },\n    [isControlled, prop, setUncontrolledProp, handleChange]\n  );\n\n  return [value, setValue] as const;\n}\n\nfunction useUncontrolledState<T>({\n  defaultProp,\n  onChange,\n}: Omit<UseControllableStateParams<T>, 'prop'>) {\n  const uncontrolledState = React.useState<T | undefined>(defaultProp);\n  const [value] = uncontrolledState;\n  const prevValueRef = React.useRef(value);\n  const handleChange = useCallbackRef(onChange);\n\n  React.useEffect(() => {\n    if (prevValueRef.current !== value) {\n      handleChange(value as T);\n      prevValueRef.current = value;\n    }\n  }, [value, prevValueRef, handleChange]);\n\n  return uncontrolledState;\n}\n\nexport { useControllableState };\n"]},"metadata":{},"sourceType":"module"}