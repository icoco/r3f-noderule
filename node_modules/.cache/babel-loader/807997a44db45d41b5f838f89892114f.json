{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LexerAdapter = void 0;\n\nconst parser_1 = require(\"../parser\");\n/**\n * Trait responsible abstracting over the interaction with Lexer output (Token vector).\n *\n * This could be generalized to support other kinds of lexers, e.g.\n * - Just in Time Lexing / Lexer-Less parsing.\n * - Streaming Lexer.\n */\n\n\nclass LexerAdapter {\n  initLexerAdapter() {\n    this.tokVector = [];\n    this.tokVectorLength = 0;\n    this.currIdx = -1;\n  }\n\n  set input(newInput) {\n    // @ts-ignore - `this parameter` not supported in setters/getters\n    //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n    if (this.selfAnalysisDone !== true) {\n      throw Error(`Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.`);\n    } // @ts-ignore - `this parameter` not supported in setters/getters\n    //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n\n\n    this.reset();\n    this.tokVector = newInput;\n    this.tokVectorLength = newInput.length;\n  }\n\n  get input() {\n    return this.tokVector;\n  } // skips a token and returns the next token\n\n\n  SKIP_TOKEN() {\n    if (this.currIdx <= this.tokVector.length - 2) {\n      this.consumeToken();\n      return this.LA(1);\n    } else {\n      return parser_1.END_OF_FILE;\n    }\n  } // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n  // or lexers dependent on parser context.\n\n\n  LA(howMuch) {\n    const soughtIdx = this.currIdx + howMuch;\n\n    if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n      return parser_1.END_OF_FILE;\n    } else {\n      return this.tokVector[soughtIdx];\n    }\n  }\n\n  consumeToken() {\n    this.currIdx++;\n  }\n\n  exportLexerState() {\n    return this.currIdx;\n  }\n\n  importLexerState(newState) {\n    this.currIdx = newState;\n  }\n\n  resetLexerState() {\n    this.currIdx = -1;\n  }\n\n  moveToTerminatedState() {\n    this.currIdx = this.tokVector.length - 1;\n  }\n\n  getLexerPosition() {\n    return this.exportLexerState();\n  }\n\n}\n\nexports.LexerAdapter = LexerAdapter;","map":{"version":3,"sources":["../../../../../src/parse/parser/traits/lexer_adapter.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,QAAA,GAAA,OAAA,CAAA,WAAA,CAAA;AAIA;;;;;;AAMG;;;AACH,MAAa,YAAb,CAAyB;AAKvB,EAAA,gBAAgB,GAAA;AACd,SAAK,SAAL,GAAiB,EAAjB;AACA,SAAK,eAAL,GAAuB,CAAvB;AACA,SAAK,OAAL,GAAe,CAAC,CAAhB;AACD;;AAEQ,MAAL,KAAK,CAAC,QAAD,EAAmB;AAC1B;AACA;AACA,QAAI,KAAK,gBAAL,KAA0B,IAA9B,EAAoC;AAClC,YAAM,KAAK,CACT,kFADS,CAAX;AAGD,KAPyB,CAQ1B;AACA;;;AACA,SAAK,KAAL;AACA,SAAK,SAAL,GAAiB,QAAjB;AACA,SAAK,eAAL,GAAuB,QAAQ,CAAC,MAAhC;AACD;;AAEQ,MAAL,KAAK,GAAA;AACP,WAAO,KAAK,SAAZ;AACD,GA5BsB,CA8BvB;;;AACA,EAAA,UAAU,GAAA;AACR,QAAI,KAAK,OAAL,IAAgB,KAAK,SAAL,CAAe,MAAf,GAAwB,CAA5C,EAA+C;AAC7C,WAAK,YAAL;AACA,aAAO,KAAK,EAAL,CAAQ,CAAR,CAAP;AACD,KAHD,MAGO;AACL,aAAO,QAAA,CAAA,WAAP;AACD;AACF,GAtCsB,CAwCvB;AACA;;;AACA,EAAA,EAAE,CAAsB,OAAtB,EAAqC;AACrC,UAAM,SAAS,GAAG,KAAK,OAAL,GAAe,OAAjC;;AACA,QAAI,SAAS,GAAG,CAAZ,IAAiB,KAAK,eAAL,IAAwB,SAA7C,EAAwD;AACtD,aAAO,QAAA,CAAA,WAAP;AACD,KAFD,MAEO;AACL,aAAO,KAAK,SAAL,CAAe,SAAf,CAAP;AACD;AACF;;AAED,EAAA,YAAY,GAAA;AACV,SAAK,OAAL;AACD;;AAED,EAAA,gBAAgB,GAAA;AACd,WAAO,KAAK,OAAZ;AACD;;AAED,EAAA,gBAAgB,CAAsB,QAAtB,EAAsC;AACpD,SAAK,OAAL,GAAe,QAAf;AACD;;AAED,EAAA,eAAe,GAAA;AACb,SAAK,OAAL,GAAe,CAAC,CAAhB;AACD;;AAED,EAAA,qBAAqB,GAAA;AACnB,SAAK,OAAL,GAAe,KAAK,SAAL,CAAe,MAAf,GAAwB,CAAvC;AACD;;AAED,EAAA,gBAAgB,GAAA;AACd,WAAO,KAAK,gBAAL,EAAP;AACD;;AAzEsB;;AAAzB,OAAA,CAAA,YAAA,GAAA,YAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LexerAdapter = void 0;\nconst parser_1 = require(\"../parser\");\n/**\n * Trait responsible abstracting over the interaction with Lexer output (Token vector).\n *\n * This could be generalized to support other kinds of lexers, e.g.\n * - Just in Time Lexing / Lexer-Less parsing.\n * - Streaming Lexer.\n */\nclass LexerAdapter {\n    initLexerAdapter() {\n        this.tokVector = [];\n        this.tokVectorLength = 0;\n        this.currIdx = -1;\n    }\n    set input(newInput) {\n        // @ts-ignore - `this parameter` not supported in setters/getters\n        //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n        if (this.selfAnalysisDone !== true) {\n            throw Error(`Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.`);\n        }\n        // @ts-ignore - `this parameter` not supported in setters/getters\n        //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n        this.reset();\n        this.tokVector = newInput;\n        this.tokVectorLength = newInput.length;\n    }\n    get input() {\n        return this.tokVector;\n    }\n    // skips a token and returns the next token\n    SKIP_TOKEN() {\n        if (this.currIdx <= this.tokVector.length - 2) {\n            this.consumeToken();\n            return this.LA(1);\n        }\n        else {\n            return parser_1.END_OF_FILE;\n        }\n    }\n    // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n    // or lexers dependent on parser context.\n    LA(howMuch) {\n        const soughtIdx = this.currIdx + howMuch;\n        if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n            return parser_1.END_OF_FILE;\n        }\n        else {\n            return this.tokVector[soughtIdx];\n        }\n    }\n    consumeToken() {\n        this.currIdx++;\n    }\n    exportLexerState() {\n        return this.currIdx;\n    }\n    importLexerState(newState) {\n        this.currIdx = newState;\n    }\n    resetLexerState() {\n        this.currIdx = -1;\n    }\n    moveToTerminatedState() {\n        this.currIdx = this.tokVector.length - 1;\n    }\n    getLexerPosition() {\n        return this.exportLexerState();\n    }\n}\nexports.LexerAdapter = LexerAdapter;\n//# sourceMappingURL=lexer_adapter.js.map"]},"metadata":{},"sourceType":"script"}